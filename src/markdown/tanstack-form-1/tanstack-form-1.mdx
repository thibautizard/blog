import Logo from "./assets/logo.png"
import Image from "next/image"
import InformationBanner from "@/markdown/-components/information-banner";
import ExternalLink from "@/markdown/-components/external-link";

export const metadata = {
  title: "Cr√©er des formulaires modernes et type-safe avec TanStack Form üìù [Partie 1 - Introduction]",
  date: "2025-07-28",
  excerpt:
    "Votre tech lead va l'adorer.",
  publish: true,
};

### L'enfer du d√©veloppeur est pav√© de mauvais formulaires

**Les formulaires sont un cauchemar incontournable dans le d√©veloppement web et mobile** : validation synchrone et asynchrone, r√©cup√©ration et affichage des erreurs, contraintes multiples, accessibilit√©, s√©rialisation et d√©serialisation des valeurs, responsivit√©, sauvegarde de l'√©tat etc. 

√Ä ces impond√©rables s'ajoutent les **diff√©rentes d√©cisions UX √† prendre** : faut-il **r√©v√©ler les erreurs √† mesure que l'utilisateur tape** afin d'√™tre le plus** **r√©actif possible au risque de le frustrer s'il n'est pas all√© au bout de sa saisie ? Ou alors le faire mais **avec un d√©lai** ? Doit-on plut√¥t attendre **qu'il sorte du champ pour les lui signaler** ? Ou n'engager **une validation globale qu'au moment de la soumission du formulaire** quitte √† faire appara√Ætre soudainement √† l'√©cran une flop√©e d'erreurs avertissant l'utilisateur qu'il doit tout reprendre depuis le d√©but au moment o√π il pensait en avoir fini ? üíÄ

D'autant que pour s'√©pargner la cr√©ation de certains composants complexes, **on aura t√¥t fait de s'en remettre √† des librairies UI** pour remplir nos formulaires avec tout un travail additionnel pour **assurer la bonne connexion avec notre propre logique de validation et de gestion des erreurs**. On tombe alors rapidement sur des cas particuliers qui nous obligent √† tordre dans tous les sens une logique d'abord simple et *in fine* √† alourdir le code.

Bref, d√®s lors qu'on veut adresser toute la complexit√© inh√©rente aux formulaires on se retrouve vite embourb√© dans **des impl√©mentations verbeuses et peu maintenables en raison de leur forte sp√©cificit√©** : chaque d√©veloppeur cr√©e son petit syst√®me de gestion de formulaires adapt√© au contexte de son site ou de son application. 

Alors quelles qualit√©s devrait pr√©senter une **librairie de formulaires digne de ce nom** pour remplacer ce qui se transforme vite en foutoir ?

- üëâ **Standardisation** : facilement r√©utilisable d'un projet √† un autre
- üëâ **Flexibilit√© et robustesse** : couvrir tous les cas d'usage sans perdre en lisibilit√© ni sacrifier sur le plan des performances
- üëâ **Abordable** : avec un co√ªt d'apprentissage le plus faible possible

La bonne nouvelle ? Un s√©rieux candidat vient de rentrer en lice pour devenir votre prochain couteau suisse dans la gestion de formulaires üòÅ !

### *The new kid in town*

Si jusqu'√† pr√©sent ce terrain √©tait domin√© par **[React Hook Form](https://react-hook-form.com/)** et **[Formik](https://formik.org/)**, une nouvelle librairie Typescriptvenue de la galaxie TanStack vient de se faire une place avec des promesses attrayantes : **[TanStack Form](https://tanstack.com/form/latest/docs/overview)**.

<a href="https://tanstack.com/form/latest/docs/overview" target="_blank">
  <Image src={Logo} className="my-12 mx-auto w-[80%]" alt="Logo de TanStack Form" />
</a>


Compatible avec React, Vue, Solid ‚Äî et bien d'autres frameworks et technologies front ‚Äî, **[TanStack Form](https://tanstack.com/form/latest/docs/overview)** offre **un typage int√©gral de votre formulaire** pour en s√©curiser et acc√©l√©rer le d√©veloppement.

Port√© √† l'√©chelle de plus grosses applications, il offre la possiblit√© particuli√®rement int√©ressante de "composer" ses **formulaires** √† l'aide d'options et de composants r√©utilisables. On peut ainsi **cr√©er notre propre fabrique de formulaires** avec des abstractions choisies mais toujours adoss√©e √† la librairie de base pour une **personnalisation encore plus fine**.

### Cr√©er son formulaire de login avec TanStack Form

Tr√™ve de bavardages, **passons aux travaux pratiques üßë‚Äçüé®** ! Cr√©ons un simple formulaire de connexion pour une application React.

<InformationBanner>
  Pour d√©marrer rapidement une nouvelle application React, on peut passer par Vite avec la commande `npm create vite@latest my-app -- --template react` puis installer TanStack Form avec `npm install @tanstack/react-form`.
</InformationBanner>

On initialise un formulaire **[TanStack Form](https://tanstack.com/form/latest/docs/overview)** de la fa√ßon suivante :

```tsx {3}
import { useForm } from "@tanstack/react-form"

const form = useForm({ ... })
```

Ce hook `useForm` va prendre plusieurs options dont **les valeurs par d√©faut des diff√©rents champs de notre formulaire**.

```tsx {4-7}
import { useForm } from "@tanstack/react-form"

const form = useForm({ 
  defaultValues: {
    username: "",
    password: "",
  },
 })
```

Tout aussi important, **une fonction** `onSubmit` qui sera appel√©e √† chaque tentative de validation.

```tsx {8-10}
import { useForm } from "@tanstack/react-form"

const form = useForm({ 
  defaultValues: {
    username: "",
    password: "",
  },
  onSubmit: async ({ value}) => {
    console.log(value)
  },
 })
```

Le `form` renvoy√© va ensuite pouvoir √™tre **consomm√© par notre composant front** pour b√¢tir le formulaire. Celui-ci contient √† la fois des **_wrappers_ qui vont venir envelopper nos inputs pour les contr√¥ler** et des **informations sur le formulaire** (est-il valide ? quelles sont les erreurs en cours ? a-t-il √©t√© alt√©r√© depuis le chargement de la page ? etc.).

Premi√®re brique √† poser : **le composant** `form.Field` dont l'attribut `name` se liera automatiquement √† l'un des champs du formulaire d√©clar√©s dans `useForm()`.

```tsx {5,16-26}
import { useForm } from "@tanstack/react-form"

const form = useForm({ 
  defaultValues: {
    username: "",
    password: "",
  },
  onSubmit: async ({ value }) => {
    console.log(value)
  },
 })

const LoginForm = () => {
  return (
    <form>
      <form.Field 
        name="username" 
        children={({field}) => 
          <input 
            id={field.id} 
            type="text"
            name={field.name} 
            value={field.state.value}
          />
        }
      />
      <form.Field 
        name="password" 
        children={({field}) => 
          <input 
            id={field.id} 
            type="password"
            name={field.name} 
            value={field.state.value}
          />
        }
      />
      <button type="submit">Login</button>
    </form>
  )
}
```

Plut√¥t que de lui passer un `children`sous la forme `<form.Field>{children}</form.Field>`, on recourt ici √† la bonne vieille technique des `renderProps`. Cela nous permet d'utiliser **une fonction de rendu plut√¥t que le composant d√©j√† rendu** afin d'exploiter le `field` sp√©cifique √† chaque champ contenant toutes les informations n√©cessaires.

Derni√®re √©tape pour assurer la validation du formulaire : **d√©sactiver le comportement par d√©faut du bouton de soumission qui survient lorsqu'un bouton** `<button type="submit">` se trouve dans un √©l√©ment `<form>`. 

<InformationBanner>
  Cette pr√©caution est cruciale pour emp√™cher le rechargement de la page qu'on souhaite √©viter dans le cadre d'une SPA car il nous ferait sortir de notre routing et court-circuiterait les op√©rations de TanStack Form. 
</InformationBanner>

On va donc devoir passer par la m√©thode `form.handleSubmit()` pour d√©clencher les √©tapes de validation et **laisser TanStack Form tester notre formulaire** et nous renvoyer toutes les informations n√©cessaires.

```tsx {16-18}
import { useForm } from "@tanstack/react-form"

const form = useForm({ 
  defaultValues: {
    username: "",
    password: "",
  },
  onSubmit: async ({ value }) => {
    console.log(value)
  },
 })

const LoginForm = () => {
  return (
    <form onSubmit={(e) => {
      e.preventDefault();
      e.stopPropagation();
      void form.handleSubmit();
    }}>
      <form.Field 
        name="username" 
        children={({field}) => 
          <input 
            id={field.id} 
            type="text"
            name={field.name} 
            value={field.state.value}
          />
        }
      />
      <form.Field 
        name="password" 
        children={({field}) => 
          <input 
            id={field.id} 
            type="password"
            name={field.name} 
            value={field.state.value}
          />
        }
      />
      <button type="submit">Login</button>
    </form>
  )
}
```

Avec TanStack Form, **nos _inputs_ sont contr√¥l√©s** par le formulaire ce qui signifie que nous devons non seulement leur passer manuellement leur valeur avec `value={field.state.value}` mais aussi **des _events handlers_ pour r√©agir √† la saisie de l'utilisateur et mettre √† jour cette m√™me valeur**. 

On utilise ainsi `onChange` sur la surface de l'input pour appeler `field.handleChange()` et mettre √† jour la valeur du champ.

```tsx {28,40}
import { useForm } from "@tanstack/react-form"

const form = useForm({ 
  defaultValues: {
    username: "",
    password: "",
  },
  onSubmit: async ({ value }) => {
    console.log(value)
  },
 })

const LoginForm = () => {
  return (
    <form onSubmit={(e) => {
      e.preventDefault();
      e.stopPropagation();
      void form.handleSubmit();
    }}>
      <form.Field 
        name="username" 
        children={({field}) => 
          <input 
            id={field.id} 
            type="text"
            name={field.name} 
            value={field.state.value}
            onChange={(e) => field.handleChange(e.target.value)}
          />
        }
      />
      <form.Field 
        name="password" 
        children={({field}) => 
          <input 
            id={field.id} 
            type="password"
            name={field.name} 
            value={field.state.value}
            onChange={(e) => field.handleChange(e.target.value)}
          />
        }
      />
      <button type="submit">Login</button>
    </form>
  )
}
```

Voil√† en deux coups de cuill√®re √† pot un bon d√©but de formulaire de connexion üòã 

Ne reste plus qu'√† **ajouter la validation des champs et la gestion des erreurs** et la **gestion des erreurs** que nous verrons dans [la partie suivante](/post/tanstack-form-2).

<div className="useful-links">
  #### üîó Liens additionnels 
  - <ExternalLink /> [Documentation officielle de TanStack Form](https://tanstack.com/form/latest/docs/overview)
  - <ExternalLink /> [TanStack Form Tutorial - Balastrong](https://www.youtube.com/watch?v=Pf1qn35bgjs&list=PLOQjd5dsGSxInTKUWTxyqSKwZCjDIUs0Y&index=1)
  - <ExternalLink /> [LogRocket ‚Äî TanStack Form vs. React Hook Form](https://blog.logrocket.com/tanstack-form-vs-react-hook-form)
</div>
