import Logo from "./assets/logo.png"
import Image from "next/image"
import InformationBanner from "@/markdown/-components/information-banner";
import ExternalLink from "@/markdown/-components/external-link";
import LinkWithGlimpse from "../-components/link-with-glimpse";

export const metadata = {
    title: "CrÃ©er des formulaires modernes et type-safe avec TanStack Form ğŸ“ [Partie 1 - Introduction]",
    date: "2025-07-28",
    excerpt:
        "Votre tech lead va l'adorer.",
};

### L'enfer du dÃ©veloppeur est pavÃ© de mauvais formulaires

**Les formulaires sont un cauchemar incontournable dans le dÃ©veloppement web et mobile** : validation synchrone et asynchrone, rÃ©cupÃ©ration et affichage des erreurs, contraintes multiples, accessibilitÃ©, sÃ©rialisation et dÃ©serialisation des valeurs, responsivitÃ©, sauvegarde de l'Ã©tat etc.

Ã€ ces impondÃ©rables s'ajoutent les **diffÃ©rentes dÃ©cisions UX Ã  prendre** : faut-il **rÃ©vÃ©ler les erreurs Ã  mesure que l'utilisateur tape** afin d'Ãªtre le plus rÃ©actif possible au risque de le frustrer s'il n'est pas allÃ© au bout de sa saisie ? Ajouter **un dÃ©lai avant de lancer la validation** ? Doit-on plutÃ´t attendre **qu'il sorte du champ pour les lui signaler** ? Ou n'engager **une validation globale qu'au moment de la soumission du formulaire** â€” quitte Ã  faire apparaÃ®tre soudainement Ã  l'Ã©cran une flopÃ©e d'erreurs avertissant l'utilisateur qu'il doit tout reprendre depuis le dÃ©but au moment mÃªme oÃ¹ il pensait en avoir fini ? ğŸ’€

D'autant que pour s'Ã©pargner la crÃ©ation de certains composants complexes, **on aura tÃ´t fait de s'en remettre Ã  des librairies UI** avec tout un travail additionnel pour **assurer la bonne connexion de ces composantsavec notre propre logique de validation et de gestion des erreurs**. On tombe alors rapidement sur **des cas particuliers** qui nous obligent Ã  tordre dans tous les sens une logique de validation d'abord simple et *in fine* Ã  alourdir le code.

Bref, dÃ¨s qu'on veut adresser toute la complexitÃ© inhÃ©rente aux formulaires on se retrouve vite embourbÃ© dans **des implÃ©mentations verbeuses et peu maintenables en raison de leur forte spÃ©cificitÃ©** : chaque dÃ©veloppeur crÃ©e son petit systÃ¨me de gestion de formulaires adaptÃ© au contexte de son site ou de son application.

DÃ¨s lors, quelles qualitÃ©s devrait prÃ©senter une **librairie de formulaires digne de ce nom** pour remplacer notre implÃ©mentation maison qui se transforme vite en foutoir ?

- ğŸ‘‰ **Standardisation** : facilement rÃ©utilisable d'un projet Ã  un autre
- ğŸ‘‰ **FlexibilitÃ© et robustesse** : couvrir tous les cas d'usage sans perdre en lisibilitÃ© ni rien sacrifier sur le plan des performances
- ğŸ‘‰ **Facile Ã  apprendre**

La bonne nouvelle ? Un sÃ©rieux candidat vient de rentrer en lice pour devenir votre prochain couteau suisse dans la gestion de formulaires ğŸ˜ !

### *The new kid in town*

Si jusqu'Ã  prÃ©sent ce terrain Ã©tait dominÃ© par **<LinkWithGlimpse url="https://react-hook-form.com/">React Hook Form</LinkWithGlimpse>** et **<LinkWithGlimpse url="https://formik.org/">Formik</LinkWithGlimpse>**, une nouvelle librairie Typescriptvenue de la galaxie TanStack vient de se faire une place avec des promesses attrayantes : **<LinkWithGlimpse url="https://tanstack.com/form/latest">TanStack Form</LinkWithGlimpse>**.



Compatible avec React, Vue, Solid â€” et bien d'autres frameworks et technologies front â€”, **<LinkWithGlimpse url="https://tanstack.com/form/latest/docs/overview">TanStack Form</LinkWithGlimpse>** offre **un typage intÃ©gral de votre formulaire** qui sÃ©curise et accÃ©lÃ¨re le dÃ©veloppement.

PortÃ© Ã  l'Ã©chelle de plus grosses applications, il offre la possiblitÃ© particuliÃ¨rement intÃ©ressante de "composer" ses **formulaires** Ã  l'aide d'options et de composants rÃ©utilisables entre diffÃ©rents formulaires.

On peut ainsi **crÃ©er notre propre fabrique de formulaires** avec des abstractions choisies mais toujours adossÃ©e Ã  la librairie de base pour une **personnalisation encore plus fine**.

### CrÃ©er son formulaire de login avec TanStack Form

TrÃªve de bavardages, **passons aux travaux pratiques ğŸ§‘â€ğŸ¨** ! CrÃ©ons un simple formulaire de connexion pour une application React.

<InformationBanner>
  Pour dÃ©marrer rapidement une nouvelle application React, on peut passer par Vite avec la commande `npm create vite@latest my-app -- --template react` puis installer TanStack Form avec `npm install @tanstack/react-form`.
</InformationBanner>

On initialise un formulaire **<LinkWithGlimpse url="https://tanstack.com/form/latest/docs/overview">TanStack Form</LinkWithGlimpse>** de la faÃ§on suivante :

```tsx
import { useForm } from "@tanstack/react-form"

const form = useForm({ ... })
```

Ce hook `useForm` va prendre plusieurs options dont **les valeurs par dÃ©faut des diffÃ©rents champs de notre formulaire**.

```tsx
import { useForm } from "@tanstack/react-form"

const form = useForm({
  defaultValues: {
    username: "",
    password: "",
  },
 })
```

Tout aussi important, **une fonction** `onSubmit` qui sera appelÃ©e Ã  chaque tentative de validation.

```tsx
import { useForm } from "@tanstack/react-form"

const form = useForm({
  defaultValues: {
    username: "",
    password: "",
  },
  onSubmit: async ({ value}) => {
    console.log(value)
  },
 })
```

Le `form` renvoyÃ© va ensuite pouvoir Ãªtre **consommÃ© par notre composant front** pour bÃ¢tir le formulaire. Ce `form` contient Ã  la fois des **composants tels que** `form.Field` **qui vont venir envelopper nos inputs pour les contrÃ´ler** mais aussi des **informations sur l'Ã©tat actuel de notre formulaire** (est-il valide ? quelles sont les erreurs en cours ? a-t-il Ã©tÃ© altÃ©rÃ© depuis le chargement de la page ? etc.).

PremiÃ¨re brique donc Ã  poser : **le composant** `form.Field` dont l'attribut `name` se liera automatiquement Ã  l'un des champs du formulaire dÃ©clarÃ©s dans `useForm()`.

```tsx
import { useForm } from "@tanstack/react-form"

const form = useForm({
  defaultValues: {
    username: "",
    password: "",
  },
  onSubmit: async ({ value }) => {
    console.log(value)
  },
 })

const LoginForm = () => {
  return (
    <form>
      <form.Field
        name="username"
        children={({field}) =>
          <input
            id={field.id}
            type="text"
            name={field.name}
            value={field.state.value}
          />
        }
      />
      <form.Field
        name="password"
        children={({field}) =>
          <input
            id={field.id}
            type="password"
            name={field.name}
            value={field.state.value}
          />
        }
      />
      <button type="submit">Login</button>
    </form>
  )
}
```

PlutÃ´t que de lui passer un `children`sous la forme `<form.Field>{children}</form.Field>`, on recourt ici Ã  la bonne vieille technique des `renderProps`. Cela nous permet d'utiliser **une fonction de rendu plutÃ´t que le composant dÃ©jÃ  rendu** afin d'exploiter le `field` spÃ©cifique Ã  chaque champ qu'on rÃ©cupÃ¨re comme argument.

DerniÃ¨re Ã©tape pour assurer la validation du formulaire : **dÃ©sactiver le comportement par dÃ©faut du bouton de soumission qui survient lorsqu'un bouton** `<button type="submit">` se trouve dans un Ã©lÃ©ment `<form>`.

<InformationBanner>
  Cette prÃ©caution est cruciale pour empÃªcher le rechargement de la page, comportement qu'on souhaite Ã©viter dans le cadre d'une SPA car il nous ferait sortir de notre routing et court-circuiterait les opÃ©rations de TanStack Form.
</InformationBanner>

On va donc devoir en passer par la mÃ©thode `form.handleSubmit()` pour **dÃ©clencher la validation du formulaire**.

```tsx
import { useForm } from "@tanstack/react-form"

const form = useForm({
  defaultValues: {
    username: "",
    password: "",
  },
  onSubmit: async ({ value }) => {
    console.log(value)
  },
 })

const LoginForm = () => {
  return (
    <form onSubmit={(e) => {
      e.preventDefault();
      e.stopPropagation();
      void form.handleSubmit();
    }}>
      <form.Field
        name="username"
        children={({field}) =>
          <input
            id={field.id}
            type="text"
            name={field.name}
            value={field.state.value}
          />
        }
      />
      <form.Field
        name="password"
        children={({field}) =>
          <input
            id={field.id}
            type="password"
            name={field.name}
            value={field.state.value}
          />
        }
      />
      <button type="submit">Login</button>
    </form>
  )
}
```

Avec TanStack Form, **nos _inputs_ sont contrÃ´lÃ©s** par le formulaire ce qui signifie que nous devons non seulement leur passer manuellement leur valeur via la prop `value={field.state.value}` mais aussi **des _events handlers_ pour rÃ©agir Ã  la saisie de l'utilisateur et mettre Ã  jour cette mÃªme valeur**.

On utilise ainsi `onChange` sur la surface de l'input pour appeler `field.handleChange()` avec la nouvelle valeur du champ.

```tsx
import { useForm } from "@tanstack/react-form"

const form = useForm({
  defaultValues: {
    username: "",
    password: "",
  },
  onSubmit: async ({ value }) => {
    console.log(value)
  },
 })

const LoginForm = () => {
  return (
    <form onSubmit={(e) => {
      e.preventDefault();
      e.stopPropagation();
      void form.handleSubmit();
    }}>
      <form.Field
        name="username"
        children={({field}) =>
          <input
            id={field.id}
            type="text"
            name={field.name}
            value={field.state.value}
            onChange={(e) => field.handleChange(e.target.value)}
          />
        }
      />
      <form.Field
        name="password"
        children={({field}) =>
          <input
            id={field.id}
            type="password"
            name={field.name}
            value={field.state.value}
            onChange={(e) => field.handleChange(e.target.value)}
          />
        }
      />
      <button type="submit">Login</button>
    </form>
  )
}
```

VoilÃ  en deux coups de cuillÃ¨re Ã  pot un bon dÃ©but de formulaire de connexion ğŸ˜‹

Ne reste plus qu'Ã  **ajouter la validation des champs** et **gÃ©rer les erreurs**, des Ã©tapes que nous verrons dans <LinkWithGlimpse url="https://www.frenchdev.co/post/tanstack-form-2">la partie suivante</LinkWithGlimpse>.

<div className="useful-links">
  #### ğŸ”— Liens additionnels
  - <ExternalLink/> <LinkWithGlimpse url="https://tanstack.com/form/latest/docs/overview">Documentation officielle de TanStack Form</LinkWithGlimpse>
  - <ExternalLink/> <LinkWithGlimpse url="https://www.youtube.com/watch?v=Pf1qn35bgjs&list=PLOQjd5dsGSxInTKUWTxyqSKwZCjDIUs0Y&index=1">TanStack Form Tutorial - Balastrong</LinkWithGlimpse>
  - <ExternalLink/> <LinkWithGlimpse url="https://blog.logrocket.com/tanstack-form-vs-react-hook-form">LogRocket â€” TanStack Form vs. React Hook Form</LinkWithGlimpse>
</div>
