import Logo from "./assets/logo.png"
import Image from "next/image"
import Link from "next/link"
import ExternalLink from "@/markdown/-components/external-link";

export const metadata = {
  title: "Cr√©er des formulaires modernes et type-safe avec TanStack Form üìù [Partie 2  - La validation]",
  date: "2025-08-02",
  excerpt:
    "On s'attaque ici √† la validation d'un formulaire avec toutes les options qu'offre TanStack Form.",
  publish: true,
};

[ Partie 1 disponible ici](/post/tanstack-form-1)

Dans la partie 1, nous avions cr√©√© un **formulaire de connexion en React contr√¥l√© par TanStack Form** avec deux champs : le nom de l'utilisateur et le mot de passe üëá

```tsx
import { useForm } from "@tanstack/react-form"

const form = useForm({ 
  defaultValues: {
    username: "",
    password: "",
  },
  onSubmit: async ({ value }) => {
    console.log(value)
  },
 })

const LoginForm = () => {
  return (
    <form onSubmit={(e) => {
      e.preventDefault();
      e.stopPropagation();
      void form.handleSubmit();
    }}>
      <form.Field 
        name="username" 
        children={({ field }) => 
          <input 
            id={field.id} 
            type="text"
            name={field.name} 
            value={field.state.value}
            onChange={(e) => field.handleChange(e.target.value)}
          />
        }
      />
      <form.Field 
        name="password" 
        children={({ field }) => 
          <input 
            id={field.id} 
            type="password"
            name={field.name} 
            value={field.state.value}
            onChange={(e) => field.handleChange(e.target.value)}
          />
        }
      />
      <button type="submit">Login</button>
    </form>
  )
}
```

Maintenant que notre formulaire est √©bauch√©, passons √† l'√©tape cruciale de la validation.

### Valider ou ne pas valider ?

La validation d'un formulaire peut intervenir √† diff√©rents moments :

- üëâ **Durant la saisie d'un champ** (r√©activit√© maximale)
- üëâ **√Ä la sortie d'un champ** (compromis entre r√©activit√© et autonomie de l'utilisateur)
- üëâ **Lorsqu'on presse sur le bouton de soumission du formulaire** (autonomie de l'utilisateur maximale mais pas de r√©activit√©)

TanStack Form nous permet de facilement **d√©finir le moment le plus opportun pour valider un ou plusieurs champs** voire m√™me de **combiner plusieurs strat√©gies de validation**.

#### Validation √† la vol√©e

La validation √† la saisie d'un champ est la plus simple et la plus r√©active. Elle permet de **tester la validit√© du champ d√®s que l'utilisateur tape un caract√®re**.

On peut la configurer **au niveau du champ concern√©** en passant une fonction de validation √† la propri√©t√©** `onChange` **des** `validators` **du champ**.

Tout ce qui est retourn√© par cette fonction est consid√©r√© comme une **erreur de validation** et sera ajout√© √† `field.state.meta.errors`. Si rien n'est retourn√© ou `null`, le champ est consid√©r√© **comme valide**.

```tsx {4-8}
  <form.Field 
        name="username" 
        validators={{
          onChange: ({ value }) => {
            if (value.length < 3) {
              return "Le nom d'utilisateur doit contenir au moins 3 caract√®res"
            }
          }
        }}
        children={({ field }) => 
          <input 
            id={field.id} 
            type="text"
            name={field.name} 
            value={field.state.value}
            onChange={(e) => field.handleChange(e.target.value)}
          />
        }
      />
```
<br/>

#### Validation √† la sortie

Lorsqu'**un champ perd son _focus_** (l'utilisateur clique en dehors de celui-ci ou se d√©place sur le prochain √©l√©ment _focusable_ √† l'aide de son clavier), **on peut d√©clencher une validation en passant **une fonction de validation √† la propri√©t√©** `onBlur` **des** `validators` **du champ**.

```tsx {4-8}
  <form.Field 
        name="username" 
        validators={
          onBlur: ({ value }) => {
            if (value.length < 3) {
              return "Le nom d'utilisateur doit contenir au moins 3 caract√®res"
            }
          }
        }
        children={({ field }) => 
          <input 
            id={field.id} 
            type="text"
            name={field.name} 
            value={field.state.value}
            onChange={(e) => field.handleChange(e.target.value)}
          />
        }
      />
```
 <br/>

 #### Validation √† la soumission

Si on ne souhaite √©prouver la validit√© du formulaire qu'apr√®s que l'utilisateur lui-m√™me estime avoir fini de le remplir, on en passera **par** `onSubmit` **d√©fini au moment de la cr√©ation du formulaire et qui sera ex√©cut√© √† chaque** `form.handleSubmit`.


```tsx {8-14}
import { useForm } from "@tanstack/react-form"

const form = useForm({ 
  defaultValues: {
    username: "",
    password: "",
  },
  validators: {
    onSubmit: ({ value }) => {
      if (!value.username.length || !value.password.length) {
        return "Le nom d'utilisateur et le mot de passe sont requis"
      }
    }
  },
  onSubmit: async ({ value }) => {
    console.log(value)
  },
 })
```

Il est tout √† fait possible de centraliser ses op√©rations de validation dans les `validators` du `form` plut√¥t qu'au niveau des `field` ce qui est pratique si on souhaite re-valider plusieurs champs en m√™me temps en fonction des interactions de l'utilisateur avec le formulaire.

De plus, rien n'emp√™che de **combiner ces diff√©rentes strat√©gies de validation** c'est-√†-dire d'en valider certains √† la vol√©e et d'autres √† la sortie ou √† la soumission du formulaire ‚Äî m√™me s'il est pr√©f√©rable de ne pas surcharger l'utilisateur d'informations ou de le frustrer en lui cr√©ant trop de crans d'arr√™t dans sa validation.

Par exemple on peut mettre en place une validation √† la vol√©e sur le champ `username` et une validation globale √† la soumission üëá


```tsx {8-14, 29-34}
import { useForm } from "@tanstack/react-form"

const form = useForm({ 
  defaultValues: {
    username: "",
    password: "",
  },
  validators: {
    onSubmit: ({ value }) => {
      if (!value.username.length || !value.password.length) {
        return "Le nom d'utilisateur et le mot de passe sont requis"
      }
    }
  },
  onSubmit: async ({ value }) => {
    console.log(value)
  },
 })

const LoginForm = () => {
  return (
    <form onSubmit={(e) => {
      e.preventDefault();
      e.stopPropagation();
      void form.handleSubmit();
    }}>
      <form.Field 
        name="username" 
        validators={{
           onBlur: ({ value }) => {
            if (value.length < 3) {
              return "Le nom d'utilisateur doit contenir au moins 3 caract√®res"
            }
          },
        }}
        children={({ field }) => 
          <input 
            id={field.id} 
            type="text"
            name={field.name} 
            value={field.state.value}
            onChange={(e) => field.handleChange(e.target.value)}
          />
        }
      />
      {/* ... */}
      <button type="submit">Login</button>
    </form>
  )
}
```
 <br/>

 #### Attendre la validation c√¥t√© serveur

 Une fois **pass√©es les validations locales c√¥t√© client**, on d√©clenche g√©n√©ralement une validation c√¥t√© serveur qui sera par nature asynchrone. C'est le moment de recourir √† la propri√©t√© `onChangeAsync` qui sera voisine et compl√©mentaire de `onChange`. Elle prendra en valeur une fonction charg√©e d'effectuer les appels API n√©cessaires pour tester l'input.


```tsx {1-13, 18}
  function validateUsername(value: string) {
    fetch(`/api/validate-username?username=${value}`)
      .then(response => response.json())
      .then(data => {
        if (data.error) {
          return "Ce nom d'utilisateur est d√©j√† pris"
        }
        return null
      })
      .catch(error => {
        return "Une erreur est survenue lors de la validation du nom d'utilisateur"
      })
  }

  <form.Field 
        name="username" 
        validators={
          onChangeAsync: ({ value }) => validateUsername(value),
          onChange: ({ value }) => {
            if (value.length < 3) {
              return "Le nom d'utilisateur doit contenir au moins 3 caract√®res"
            }
          }
        }
        children={({ field }) => 
          <input 
            id={field.id} 
            type="text"
            name={field.name} 
            value={field.state.value}
            onChange={(e) => field.handleChange(e.target.value)}
          />
        }
      />
```

√Ä noter que **la validation** `onChangeAsync` **ne se d√©clenchera qu'<u>apr√®s</u> les validations** `onChange` **r√©ussies**. En suivant cet ordre, on √©vite de solliciter inutilement une API si l'input peut d√©j√† √™tre d√©tect√© comme invalide avant l'envoi de la requ√™te.
 
 #### Afficher une erreur de validation pour un champ

Pour v√©rifier que la validation sp√©cifique √† un champ fonctionne, on peut afficher directement sous notre `input` les erreurs associ√©es. Il suffit d'inspecter **la propri√©t√©** `field` **qui va nous livrer un tableau d'erreurs √† exploiter du c√¥t√© du rendu** (tableau vide si le champ est valide).

```tsx {19}
  <form.Field 
        name="username" 
        validators={
          onBlur: ({ value }) => {
            if (value.length < 3) {
              return "Le nom d'utilisateur doit contenir au moins 3 caract√®res"
            }
          }
        }
        children={({ field }) => 
          <>
            <input 
              id={field.id} 
              type="text"
              name={field.name} 
              value={field.state.value}
              onChange={(e) => field.handleChange(e.target.value)}
            />
            <div key={error} className="text-red-500">{field.state.meta.errors}</div>
          </>
        }
      />
```

**L'erreur dispara√Æt automatiquement lorsque le champ est repris par l'utilisateur en attendant le prochain cycle de validation** qui sera d√©clench√© par la saisie d'un nouveau caract√®re, le changement de focus ou la soumission du formulaire.

 #### Afficher une erreur de validation pour le formulaire

Si on effectue une validation globale, **c'est du c√¥t√© de l'objet `form` qu'on va r√©cup√©rer nos erreurs de validation**. On serait alors tent√© d'√©crire ceci :

```tsx {24}
import { useForm } from "@tanstack/react-form"

const form = useForm({ 
  defaultValues: {
    username: "",
    password: "",
  },
  validators: {
    onSubmit: ({ value }) => {
      if (!value.username.length || !value.password.length) {
        return "Le nom d'utilisateur et le mot de passe sont requis"
      }
    }
  },
  onSubmit: async ({ value }) => {
    console.log(value)
  },
 })

const LoginForm = () => {
  return (
    <form {...}>
      {/* ... */}
      <div>{form.state.errors}</div>
      <button type="submit">Login</button>
    </form>
  )
}
```

Cependant on risque de **ne pas afficher l'erreur** au moment o√π elle est cr√©√©e ! Pourquoi donc ? Par souci d'optimisation, **TanStack Form ne veut pas forcer React √† rendre l'enti√®re du composant contenant le formulaire √† chaque modification du** `form`. Imaginons que votre `<form>` soit pris dans un composant bien plus large : si le hook `useForm` est appel√© √† la hauteur de ce composant un nouveau rendu √† chaque modification du formulaire pourrait entra√Æner le rendu de tous les √©l√©ments et composants enfants m√™me s'ils n'ont rien √† voir avec la partie d√©di√©e au formulaire : cela pourrait entra√Æner **une d√©gradation des performances si ces changements surviennent trop fr√©quemment**. ü§∑‚Äç‚ôÇÔ∏è

Pour contourner cette difficult√©, TanStack Form d√©sactive le rendu automatique du composant comportant le `<form>` et propose un composant `<form.Subscribe>` qui permet **de s'abonner √† un changement sp√©cifique du `form` et de rendre uniquement la portion qu'il enveloppe**.

```tsx {4-8}
const LoginForm = () => {
  return (
    <form {...}>
      <form.Subscribe
        selector={(state) => state.errors} 
         children={({ errors }) => 
            errors.length > 0 && <div>{errors}</div>
          }/>
      <button type="submit">Login</button>
    </form>
  )
}
```

Voil√† ! Nous disposons √† pr√©sent d'un **formulaire op√©rationnel**. Mais on peut encore r√©hausser l'exp√©rience utilisateur en ajoutant des **indicateurs de chargement ou de validation** avant l'affichage des erreurs pour rendre l'exp√©rience plus fluide et agr√©able üåä

Ce point fera l'objet d'une derni√®re partie (_√† venir_).

<div className="useful-links">
  #### üîó Liens additionnels 
  - <ExternalLink /> [Documentation officielle de TanStack Form](https://tanstack.com/form/latest/docs/overview)
  - <ExternalLink /> [TanStack Form Tutorial - Balastrong](https://www.youtube.com/watch?v=Pf1qn35bgjs&list=PLOQjd5dsGSxInTKUWTxyqSKwZCjDIUs0Y&index=1)
  - <ExternalLink /> [LogRocket ‚Äî TanStack Form vs. React Hook Form](https://blog.logrocket.com/tanstack-form-vs-react-hook-form)
</div>
