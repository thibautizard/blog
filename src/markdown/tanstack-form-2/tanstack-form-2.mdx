import Logo from "./assets/logo.png"
import Image from "next/image"
import Link from "next/link"
import ExternalLink from "@/markdown/-components/external-link";

export const metadata = {
  title: "Cr√©er des formulaires modernes et type-safe avec TanStack Form üìù [Partie 2  - La validation]",
  date: "2025-08-02",
  excerpt:
    "On s'attaque ici √† la validation d'un formulaire avec toutes les options qu'offre TanStack Form.",
  publish: true,
};

[Cr√©er des formulaires modernes et type-safe avec TanStack Form - Partie 1](/post/tanstack-form-1)

Dans une premi√®re partie, nous avions cr√©√© un **formulaire de connexion en React contr√¥l√© par TanStack Form** avec deux champs : le nom de l'utilisateur et le mot de passe üëá

```tsx
import { useForm } from "@tanstack/react-form"

const form = useForm({ 
  defaultValues: {
    username: "",
    password: "",
  },
  onSubmit: async ({ value }) => {
    console.log(value)
  },
 })

const LoginForm = () => {
  return (
    <form onSubmit={(e) => {
      e.preventDefault();
      e.stopPropagation();
      void form.handleSubmit();
    }}>
      <form.Field 
        name="username" 
        children={({ field }) => 
          <input 
            id={field.id} 
            type="text"
            name={field.name} 
            value={field.state.value}
            onChange={(e) => field.handleChange(e.target.value)}
          />
        }
      />
      <form.Field 
        name="password" 
        children={({ field }) => 
          <input 
            id={field.id} 
            type="password"
            name={field.name} 
            value={field.state.value}
            onChange={(e) => field.handleChange(e.target.value)}
          />
        }
      />
      <button type="submit">Login</button>
    </form>
  )
}
```

Maintenant que notre formulaire est √©bauch√©, passons √† l'√©tape cruciale de la validation.

### Valider ou ne pas valider ?

La validation d'un formulaire peut intervenir √† diff√©rents moments :

- üëâ **Durant la saisie d'un champ** (r√©activit√© maximale)
- üëâ **√Ä la sortie d'un champ** (compromis entre r√©activit√© et autonomie de l'utilisateur)
- üëâ **Lorsqu'on presse sur le bouton de soumission du formulaire** (autonomie de l'utilisateur maximale mais pas de r√©activit√©)

TanStack Form nous permet de facilement **d√©finir le moment le plus opportun pour valider un ou plusieurs champs** voire de **combiner plusieurs strat√©gies de validation**.

#### Validation √† la vol√©e

La validation √† la saisie d'un champ est la plus simple et la plus r√©active. Elle permet de **tester la validit√© du champ d√®s que l'utilisateur tape un caract√®re**.

On peut la configurer **au niveau du champ concern√©** en passant une fonction de validation √† la propri√©t√© `onChange` **des** `validators` **du champ**.

Tout ce qui est retourn√© par cette fonction sera consid√©r√© comme une **erreur de validation** et automatiquement ajout√© au tableau `field.state.meta.errors`. Si cette fonction ne retourne rien (`undefined`) ou `null`, le champ est consid√©r√© **comme valide**.

```tsx {4-8}
  <form.Field 
        name="username" 
        validators={{
          onChange: ({ value }) => {
            if (value.length < 3) {
              return "Le nom d'utilisateur doit contenir au moins 3 caract√®res"
            }
          }
        }}
        children={({ field }) => 
          <input 
            id={field.id} 
            type="text"
            name={field.name} 
            value={field.state.value}
            onChange={(e) => field.handleChange(e.target.value)}
          />
        }
      />
```
<br/>

#### Validation √† la sortie

Lorsqu'**un champ perd son _focus_** (l'utilisateur clique en dehors de celui-ci ou se d√©place sur le prochain √©l√©ment _focusable_ √† l'aide de son clavier), on peut d√©clencher une validation en passant **une fonction √† la propri√©t√©** `onBlur` **des** `validators` **du champ**.

```tsx {4-8}
  <form.Field 
        name="username" 
        validators={
          onBlur: ({ value }) => {
            if (value.length < 3) {
              return "Le nom d'utilisateur doit contenir au moins 3 caract√®res"
            }
          }
        }
        children={({ field }) => 
          <input 
            id={field.id} 
            type="text"
            name={field.name} 
            value={field.state.value}
            onChange={(e) => field.handleChange(e.target.value)}
          />
        }
      />
```
 <br/>

 #### Validation √† la soumission

Si on ne souhaite √©prouver la validit√© du formulaire qu'apr√®s que l'utilisateur lui-m√™me estime avoir fini de le remplir, on en passera **par** `onSubmit` **qui sera ex√©cut√© √† chaque appel de** `form.handleSubmit`.


```tsx {8-14}
import { useForm } from "@tanstack/react-form"

const form = useForm({ 
  defaultValues: {
    username: "",
    password: "",
  },
  validators: {
    onSubmit: ({ value }) => {
      if (!value.username.length || !value.password.length) {
        return "Le nom d'utilisateur et le mot de passe sont requis"
      }
    }
  },
  onSubmit: async ({ value }) => {
    console.log(value)
  },
 })
```

De plus, rien n'emp√™che de **combiner ces diff√©rentes strat√©gies de validation** c'est-√†-dire d'en valider certains √† la vol√©e, d'autres √† la sortie, d'autres √† la soumission du formulaire etc. ‚Äî m√™me s'il est pr√©f√©rable de ne pas surcharger l'utilisateur d'informations ou de le frustrer en lui cr√©ant trop de crans d'arr√™t dans sa validation.

Par exemple on peut mettre en place une validation au changement de *focus* sur le champ `username` et une validation globale qui v√©rifie que les deux champs pr√©sentent une valeur non vide √† la soumission üëá


```tsx {8-14, 29-34}
import { useForm } from "@tanstack/react-form"

const form = useForm({ 
  defaultValues: {
    username: "",
    password: "",
  },
  validators: {
    onSubmit: ({ value }) => {
      if (!value.username.length || !value.password.length) {
        return "Le nom d'utilisateur et le mot de passe sont requis"
      }
    }
  },
  onSubmit: async ({ value }) => {
    console.log(value)
  },
 })

const LoginForm = () => {
  return (
    <form onSubmit={(e) => {
      e.preventDefault();
      e.stopPropagation();
      void form.handleSubmit();
    }}>
      <form.Field 
        name="username" 
        validators={{
           onBlur: ({ value }) => {
            if (value.length < 3) {
              return "Le nom d'utilisateur doit contenir au moins 3 caract√®res"
            }
          },
        }}
        children={({ field }) => 
          <input 
            id={field.id} 
            type="text"
            name={field.name} 
            value={field.state.value}
            onChange={(e) => field.handleChange(e.target.value)}
          />
        }
      />
      {/* ... */}
      <button type="submit">Login</button>
    </form>
  )
}
```
 <br/>

 #### Attendre la validation c√¥t√© serveur

 Jusqu'√† pr√©sent, nous avons mis en place des validations simples qui se basent uniquement sur la valeur du champ d√©j√† disponible c√¥t√© client. Mais *quid* **si on souhaite v√©rifier la validit√© d'un champ en l'envoyant √† une API** ? On passe alors √† une validation asynchrone plus d√©licate car elle **n√©cessite d'attendre la r√©ponse de l'API (qui peut √™tre longue ou m√™me ne jamais arriver) pour d√©terminer si le champ est valide ou non**.

  C'est le moment de recourir √† la propri√©t√© `onChangeAsync` qui sera voisine et compl√©mentaire de `onChange` (l√† encore il existe des `onBlurAsync` et `onSubmitAsync` qui sont les pendants de `onBlur` et `onSubmit`). Elle prendra en valeur **une nouvelle fonction charg√©e d'effectuer les appels API n√©cessaires pour tester l'input**.


```tsx {18}
  function validateUsername(value: string) {
    fetch(`/api/validate-username?username=${value}`)
      .then(response => response.json())
      .then(data => {
        if (data.error) {
          return "Ce nom d'utilisateur est d√©j√† pris"
        }
        return null
      })
      .catch(error => {
        return "Une erreur est survenue lors de la validation du nom d'utilisateur"
      })
  }

  <form.Field 
        name="username" 
        validators={
          onChangeAsync: ({ value }) => validateUsername(value),
          onChange: ({ value }) => {
            if (value.length < 3) {
              return "Le nom d'utilisateur doit contenir au moins 3 caract√®res"
            }
          }
        }
        children={({ field }) => 
          <input 
            id={field.id} 
            type="text"
            name={field.name} 
            value={field.state.value}
            onChange={(e) => field.handleChange(e.target.value)}
          />
        }
      />
```

√Ä noter que **la validation** `onChangeAsync` **ne se d√©clenchera qu'<u>une fois</u> les validations** `onChange` **r√©ussies**. En suivant cet ordre, on √©vite de solliciter inutilement une API car si l'input est d√©j√† d√©tect√© comme invalide avant toute v√©rification ext√©rieure, il est inutile de l'envoyer √† l'API.
 
 #### Afficher une erreur de validation pour un champ

Pour v√©rifier que la validation sp√©cifique √† un champ fonctionne, on affichera le plus souvent sous notre `input` les messages d'erreur associ√©s. Il suffit d'inspecter **la propri√©t√©** `field.state.meta.errors` **qui va nous livrer un tableau d'erreurs** (tableau vide si le champ est valide).

```tsx {19}
  <form.Field 
        name="username" 
        validators={
          onBlur: ({ value }) => {
            if (value.length < 3) {
              return "Le nom d'utilisateur doit contenir au moins 3 caract√®res"
            }
          }
        }
        children={({ field }) => 
          <>
            <input 
              id={field.id} 
              type="text"
              name={field.name} 
              value={field.state.value}
              onChange={(e) => field.handleChange(e.target.value)}
            />
            <div key={error} className="text-red-500">{field.state.meta.errors}</div>
          </>
        }
      />
```

**L'erreur dispara√Æt automatiquement entre le moment o√π le champ est repris par l'utilisateur et le prochain cycle de validation** qui sera d√©clench√© par la saisie d'un nouveau caract√®re, le changement de focus ou la soumission du formulaire.

 #### Afficher une erreur de validation pour le formulaire

Si on effectue une validation globale, **c'est du c√¥t√© de l'objet** `form` **qu'on va r√©cup√©rer nos erreurs de validation**. On serait alors tent√© d'√©crire ceci :

```tsx {24}
import { useForm } from "@tanstack/react-form"

const form = useForm({ 
  defaultValues: {
    username: "",
    password: "",
  },
  validators: {
    onSubmit: ({ value }) => {
      if (!value.username.length || !value.password.length) {
        return "Le nom d'utilisateur et le mot de passe sont requis"
      }
    }
  },
  onSubmit: async ({ value }) => {
    console.log(value)
  },
 })

const LoginForm = () => {
  return (
    <form {...}>
      {/* ... */}
      <div>{form.state.errors}</div>
      <button type="submit">Login</button>
    </form>
  )
}
```

Cependant on risque de **ne pas afficher l'erreur** au moment o√π elle est cr√©√©e ! Pourquoi ? Car par souci d'optimisation, **TanStack Form ne veut pas forcer React √† rendre l'enti√®ret√© du composant contenant le formulaire √† chaque modification interne du** `form`. 

Imaginons que le `<form>` soit pris dans un composant bien plus large : si le hook `useForm` qui retourne notre objet `form` est appel√© √† la hauteur de ce composant, une modification du formulaire pourrait entra√Æner le rendu de tous les √©l√©ments et composants enfants y compris ceux n'ont rien √† voir avec la partie d√©di√©e au formulaire. Il en r√©sulterait **une d√©gradation des performances si ces changements surviennent trop fr√©quemment**. ü§∑‚Äç‚ôÇÔ∏è

Pour contourner cette difficult√©, TanStack Form d√©sactive le rendu automatique du composant comportant le `<form>` et propose un composant `<form.Subscribe>` qui permet **de s'abonner √† un changement sp√©cifique du** `form` **et de rendre uniquement la portion qu'il enveloppe**.

```tsx {4-8}
const LoginForm = () => {
  return (
    <form {...}>
      <form.Subscribe
        selector={(state) => state.errors} 
         children={({ errors }) => 
            errors.length > 0 && <div>{errors}</div>
          }/>
      <button type="submit">Login</button>
    </form>
  )
}
```

Dans l'exemple ci-dessus, on utilise le composant `<form.Subscribe>` avec une propri√©t√© `selector` pour d√©terminer les informations √† surveiller (ici les erreurs globales du formulaire) puis on passe √† sa prop `children` une fonction prenant pour argument ce `selector` et renvoyant en √©change **la portion UI qui doit r√©agir lorsque cette information change**. 

Voil√† ! Nous disposons √† pr√©sent d'un **formulaire op√©rationnel**. Mais on peut encore r√©hausser l'exp√©rience utilisateur en ajoutant des **indicateurs de chargement ou de validation** avant l'affichage des erreurs pour rendre l'exp√©rience bien plus fluide et agr√©able üåä

Ce point, ainsi que diverses am√©liorations que l'on peut apporter √† notre formulaire gr√¢ce √† TanStack Form, feront l'objet d'[une derni√®re partie](/post/tanstack-form-advanced).

<div className="useful-links">
  #### üîó Liens additionnels 
  - <ExternalLink /> [Documentation officielle de TanStack Form](https://tanstack.com/form/latest/docs/overview)
  - <ExternalLink /> [TanStack Form Tutorial - Balastrong](https://www.youtube.com/watch?v=Pf1qn35bgjs&list=PLOQjd5dsGSxInTKUWTxyqSKwZCjDIUs0Y&index=1)
  - <ExternalLink /> [LogRocket ‚Äî TanStack Form vs. React Hook Form](https://blog.logrocket.com/tanstack-form-vs-react-hook-form)
</div>
