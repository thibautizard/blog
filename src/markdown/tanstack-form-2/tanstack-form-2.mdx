import Logo from "./assets/logo.png"
import Image from "next/image"
import Link from "next/link"
import ExternalLink from "@/markdown/-components/external-link";

export const metadata = {
  title: "Cr√©er des formulaires modernes et type-safe avec Tanstack Form üìù [Partie 2  - La validation]",
  date: "2025-08-02",
  excerpt:
    "On s'attaque ici √† la validation d'un formulaire avec toutes les options qu'offre TanStack Form.",
  publish: true,
};

<Link href="/post/tanstack-form-1" className="text-blue-500 underline">
  Partie 1 disponible ici
</Link>

Dans la partie 1, nous avions cr√©√© un **formulaire de connexion en React contr√¥l√© par TanStack Form** avec deux champs : le nom d'utilisateur et le mot de passe üëá

```tsx {5,6}
import { useForm } from "@tanstack/react-form"

const form = useForm({ 
  defaultValues: {
    username: "",
    password: "",
  },
  onSubmit: async ({ value }) => {
    console.log(value)
  },
 })

const LoginForm = () => {
  return (
    <form onSubmit={(e) => {
      e.preventDefault();
      e.stopPropagation();
      void form.handleSubmit();
    }}>
      <form.Field 
        name="username" 
        children={({ field }) => 
          <input 
            id={field.id} 
            type="text"
            name={field.name} 
            value={field.state.value}
            onChange={(e) => field.handleChange(e.target.value)}
          />
        }
      />
      <form.Field 
        name="password" 
        children={({ field }) => 
          <input 
            id={field.id} 
            type="password"
            name={field.name} 
            value={field.state.value}
            onChange={(e) => field.handleChange(e.target.value)}
          />
        }
      />
      <button type="submit">Login</button>
    </form>
  )
}
```

Maintenant que notre formulaire est √©bauch√©, passons √† l'√©tape cruciale de la validation.

### Valider ou ne pas valider ?

La validation d'un formulaire peut intervenir √† diff√©rents moments :

- üëâ **Durant la saisie d'un champ** (r√©activit√© maximale)
- üëâ **√Ä la sortie d'un champ** (compromis entre r√©activit√© et autonomie de l'utilisateur)
- üëâ **Lorsqu'on presse sur le bouton de soumission du formulaire** (autonomie de l'utilisateur maximale)

TanStack Form nous permet de facilement **d√©finir le moment le plus opportun pour valider un ou plusieurs champs** voire de **combiner plusieurs strat√©gies de validation**.

#### Validation √† la vol√©e

La validation √† la saisie d'un champ est la plus simple et la plus r√©active. Elle permet de tenter de **valider le champ d√®s que l'utilisateur tape un caract√®re**.

On peut la configurer **au niveau du champ concern√©** en passant une fonction de validation √† la prop `validators.onChange`.

Tout ce qui est retourn√© par cette fonction est consid√©r√© comme une **erreur de validation** et sera ajout√© √† `field.state.meta.errors`. Si rien n'est retourn√© ou `null`, le champ est consid√©r√© **comme valide**.

```tsx {4-8}
  <form.Field 
        name="username" 
        validators={
          onChange: ({ value }) => {
            if (value.length < 3) {
              return "Le nom d'utilisateur doit contenir au moins 3 caract√®res"
            }
          }
        }
        children={({ field }) => 
          <input 
            id={field.id} 
            type="text"
            name={field.name} 
            value={field.state.value}
            onChange={(e) => field.handleChange(e.target.value)}
          />
        }
      />
```
<br/>

#### Validation √† la sortie

Lorsqu'**un champ perd son _focus_** (l'utilisateur clique en dehors de celui-ci ou se d√©place sur le prochain √©l√©ment _focusable_ √† l'aide de son clavier), **on peut d√©clencher une validation en passant une fonction de validation √† la propri√©t√© `validators.onBlur`**.

```tsx {4-8}
  <form.Field 
        name="username" 
        validators={
          onBlur: ({ value }) => {
            if (value.length < 3) {
              return "Le nom d'utilisateur doit contenir au moins 3 caract√®res"
            }
          }
        }
        children={({ field }) => 
          <input 
            id={field.id} 
            type="text"
            name={field.name} 
            value={field.state.value}
            onChange={(e) => field.handleChange(e.target.value)}
          />
        }
      />
```
 <br/>

 #### Validation √† la soumission

Si on ne souhaite √©prouver la validit√© du formulaire qu'apr√®s que l'utilisateur estime avoir fini de le remplir, on en passer **par `validators.onSubmit` d√©fini au moment de la cr√©ation du formulaire et qui sera ex√©cut√© ) chaque `form.handleSubmit`**.


```tsx {8-14}
import { useForm } from "@tanstack/react-form"

const form = useForm({ 
  defaultValues: {
    username: "",
    password: "",
  },
  validators: {
    onSubmit: ({ value }) => {
      if (!value.username.length || !value.password.length) {
        return "Le nom d'utilisateur et le mot de passe sont requis"
      }
    }
  },
  onSubmit: async ({ value }) => {
    console.log(value)
  },
 })
```

De plus, rien n'emp√™che de **combiner ces diff√©rentes strat√©gies de validation** ‚Äî m√™me s'il est pr√©f√©rable de ne pas surcharger l'utilisateur d'informations ou de le frustrer en lui cr√©ant trop de crans d'arr√™t dans sa validation.

Par exemple on peut mettre en place une validation √† la vol√©e sur le champ `username` et une validation globale √† la soumission üëá


```tsx {8-14, 29-34}
import { useForm } from "@tanstack/react-form"

const form = useForm({ 
  defaultValues: {
    username: "",
    password: "",
  },
  validators: {
    onSubmit: ({ value }) => {
      if (!value.username.length || !value.password.length) {
        return "Le nom d'utilisateur et le mot de passe sont requis"
      }
    }
  },
  onSubmit: async ({ value }) => {
    console.log(value)
  },
 })

const LoginForm = () => {
  return (
    <form onSubmit={(e) => {
      e.preventDefault();
      e.stopPropagation();
      void form.handleSubmit();
    }}>
      <form.Field 
        name="username" 
        validators={
           onBlur: ({ value }) => {
            if (value.length < 3) {
              return "Le nom d'utilisateur doit contenir au moins 3 caract√®res"
            }
          },
        }
        children={({ field }) => 
          <input 
            id={field.id} 
            type="text"
            name={field.name} 
            value={field.state.value}
            onChange={(e) => field.handleChange(e.target.value)}
          />
        }
      />
      {/* ... */}
      <button type="submit">Login</button>
    </form>
  )
}
```
 <br/>

 #### Attendre la validation c√¥t√© serveur

 Une fois **pass√©es les validations locales c√¥t√© client**, on peut ensuite d√©clencher une validation c√¥t√© serveur qui sera par nature asynchrone en **recourant au champ `validators.onChangeAsync`**.


```tsx {1, 18}
  function validateUsername(value: string) {
    fetch(`/api/validate-username?username=${value}`)
      .then(response => response.json())
      .then(data => {
        if (data.error) {
          return "Ce nom d'utilisateur est d√©j√† pris"
        }
        return null
      })
      .catch(error => {
        return "Une erreur est survenue lors de la validation du nom d'utilisateur"
      })
  }

  <form.Field 
        name="username" 
        validators={
          onChangeAsync: ({ value }) => validateUsername(value),
          onChange: ({ value }) => {
            if (value.length < 3) {
              return "Le nom d'utilisateur doit contenir au moins 3 caract√®res"
            }
          }
        }
        children={({ field }) => 
          <input 
            id={field.id} 
            type="text"
            name={field.name} 
            value={field.state.value}
            onChange={(e) => field.handleChange(e.target.value)}
          />
        }
      />
```

√Ä noter que **la validation** `onChangeAsync` **ne se d√©clenchera qu'apr√®s les validations** `onChange` **r√©ussies** pour √©viter de solliciter inutilement une API si l'input s'av√®re d√©j√† invalide au moment de l'envoi de la requ√™te.
 
 #### Afficher une erreur de validation pour un champ

Pour v√©rifier que la validation sp√©cifique √† un champ fonctionne, on peut afficher directement sous notre `input` la ou les erreurs associ√©(e)s si elle(s) existe(nt). Il suffit d'inspecter **la propri√©t√© `field.state.meta.errors`** qui va nous livrer un tableau d'erreurs √† exploiter du c√¥t√© du rendu (tableau vide si le champ est valide).

```tsx {19}
  <form.Field 
        name="username" 
        validators={
          onBlur: ({ value }) => {
            if (value.length < 3) {
              return "Le nom d'utilisateur doit contenir au moins 3 caract√®res"
            }
          }
        }
        children={({ field }) => 
          <>
            <input 
              id={field.id} 
              type="text"
              name={field.name} 
              value={field.state.value}
              onChange={(e) => field.handleChange(e.target.value)}
            />
            <div key={error} className="text-red-500">{field.state.meta.errors}</div>
          </>
        }
      />
```

**L'erreur dispara√Æt automatiquement lorsque le champ est repris par l'utilisateur** avant le prochain cycle de validation ce qui assurer une r√©activit√© totale.

 #### Afficher une erreur de validation pour le formulaire

Si on effectue une validation globale, **il faut regarder c√¥t√© de l'objet `form` pour r√©cup√©rer notre erreur de validation**. On serait alors tent√© d'√©crire ceci :

```tsx {24}
import { useForm } from "@tanstack/react-form"

const form = useForm({ 
  defaultValues: {
    username: "",
    password: "",
  },
  validators: {
    onSubmit: ({ value }) => {
      if (!value.username.length || !value.password.length) {
        return "Le nom d'utilisateur et le mot de passe sont requis"
      }
    }
  },
  onSubmit: async ({ value }) => {
    console.log(value)
  },
 })

const LoginForm = () => {
  return (
    <form {...}>
      {/* ... */}
      <div>{form.state.errors}</div>
      <button type="submit">Login</button>
    </form>
  )
}
```

Mais on risque pourtant de **ne pas afficher l'erreur** pile au moment o√π elle est cr√©√©e ! Pourquoi ? Car par souci d'optimisation, **TanStack Form ne rend pas l'enti√®re du composant contenant le formulaire √† chaque modification du** `form` ‚Äî √† la diff√©rence du `field` qui reg√©n√®re son `children` d√®s qu'il s'actualise. En effet, il n'y a de n√©cessit√© √† rendre un composant potentiellement tr√®s volumineux pour un simple changement d'√©tat du `form` qu'on a d√©fini √† l'int√©rieur de celui-ci : cela pourrait entra√Æner **une d√©gradation des performances si ces changements surviennent trop fr√©quemment**. ü§∑‚Äç‚ôÇÔ∏è

Pour contourner cette difficult√©, TanStack Form propose donc un composant `<form.Subscribe>` qui permet **de s'abonner √† un changement sp√©cifique du `form` et de rendre uniquement la portion UI qu'il enveloppe**.

```tsx {4-8}
const LoginForm = () => {
  return (
    <form {...}>
      <form.Subscribe
        selector={(state) => state.errors} 
         children={({ errors }) => 
            errors.length > 0 && <div>{errors}</div>
          }/>
      <button type="submit">Login</button>
    </form>
  )
}
```

Voil√† ! Nous disposons √† pr√©sent d'un **formulaire op√©rationnel**. Mais on peut encore r√©hausser l'exp√©rience utilisateur en ajoutant des **indicateurs de chargement ou de validation** avant l'affichage des erreurs pour rendre l'exp√©rience plus fluide et agr√©able. Ce point fera l'objet d'une derni√®re partie (_√† venir_).

<div className="useful-links">
  #### üîó Liens additionnels 
  - <ExternalLink /> [Documentation officielle de TanStack Form](https://tanstack.com/form/latest/docs/overview)
  - <ExternalLink /> [TanStack Form Tutorial - Balastrong](https://www.youtube.com/watch?v=Pf1qn35bgjs&list=PLOQjd5dsGSxInTKUWTxyqSKwZCjDIUs0Y&index=1)
  - <ExternalLink /> [LogRocket ‚Äî TanStack Form vs. React Hook Form](https://blog.logrocket.com/tanstack-form-vs-react-hook-form)
</div>