import ClassicSelect from "./assets/classic-select";
import BaseSelect from "./assets/base-select";
import BaseSelectFrameworks from "./assets/base-select-frameworks";
import BaseSelectGithub from "./assets/base-select-github";
import LinkWithGlimpse from "@/markdown/-components/link-with-glimpse";
import BaselineStatus from "@/markdown/-components/baseline-status";
import { Select, SelectContent, SelectGroup, SelectItem, SelectLabel, SelectTrigger, SelectValue } from "./assets/shadcn-select";
import SpidermanSelect from "./assets/images/spiderman-select.jpg";
import ScoobyDooSelect from "./assets/images/scooby-doo-select.jpg";
import Image from "next/image";

export const metadata = {
    title: "La malÃ©diction des select enfin levÃ©e ? ğŸ‘¨â€ğŸ¨ ",
    date: "2025-12-24",
    excerpt: "Plus besoin de passer par une librairie pour avoir des select stylÃ©s ğŸ˜",
}

Tout dÃ©veloppeur frontend **connaÃ®t comme sa poche le** `<select>` **pour crÃ©er un menu dÃ©roulant** ğŸ‘‡
<ClassicSelect />

```html
<select>
    <option value="1">Apple ğŸ</option>
    <option value="2">Banana ğŸŒ</option>
    <option value="3">Cherry ğŸ’</option>
</select>
```

Au grand dam des dÃ©veloppeurs, **ce** `<select>` **Ã©tait pourtant trÃ¨s peu personnalisable**.

Impossible, par exemple, de **changer directement la flÃ¨che Ã  droite du selecteur** ou **l'apparence des options du menu dÃ©roulant** sans des stratÃ©gies de contournement qui donnaient l'impression de travailler contre la plateforme web plutÃ´t qu'avec elle.

On se retrouve alors **coincÃ© avec un rendu visuel dictÃ© par le navigateur et le systÃ¨me d'exploitation de l'utilisateur** soit une apparence variabe d'un client Ã  un autre. Pas l'idÃ©al pour un site ou une application qui cherche Ã  maintenir une cohÃ©rence visuelle et une expÃ©rience unique pour tous ses visiteurs...

La tentation est alors forte de **recrÃ©er soi-mÃªme** un `<select>` en bricolant Ã  l'aide de `<div>` ou de `<button>` ou de **se tourner vers des librairies de composants** exploitant cette voie pour nous donner la main complÃ¨te sur son apparence.

Jetons un Å“il par exemple au `select` de la librairie <LinkWithGlimpse url="https://ui.shadcn.com/docs/components/select">Shadcn UI</LinkWithGlimpse>, l'une des bibliothÃ¨ques de composants les plus populaires ğŸ‘‡

<div className="max-w-[200px] flex my-10 flex-col gap-2 mx-auto">
 <label className="font-bold text-decoration-underline" htmlFor="select">
   <span> `<select>` Shadcn UI </span>
 </label>
 <Select>
      <SelectTrigger className="w-[180px]">
        <SelectValue placeholder="Select a fruit" />
      </SelectTrigger>
      <SelectContent>
        <SelectGroup>
          <SelectItem value="apple">Apple ğŸ</SelectItem>
          <SelectItem value="banana">Banana ğŸŒ</SelectItem>
          <SelectItem value="cherry">Cherry ğŸ’</SelectItem>
          <SelectItem value="blueberry">Blueberry ğŸ«</SelectItem>
          <SelectItem value="grapes">Grapes ğŸ‡</SelectItem>
          <SelectItem value="kiwi">Kiwi ğŸ¥</SelectItem>
          <SelectItem value="lemon">Lemon ğŸ‹</SelectItem>
        </SelectGroup>
      </SelectContent>
    </Select>
</div>

MÃªme fonctionnement, mÃªme apparence. On croirait un vrai ! ğŸª

<Image src={SpidermanSelect} alt="Spiderman select" className="mx-auto my-8 w-125" width={400} height={300} />

Ã€ la lecture du code source, on rÃ©alise toutefois qu'**il ne s'agit pas d'un** `<select>` mais d'un `<button>` augmentÃ© d'une ribambelle d'attributs et qui requiert **d'importer une librairie Javascript** (ici `@radix-ui/react-select`) pour pouvoir fonctionner comme un `<select>` natif.

```tsx
import * as SelectPrimitive from "@radix-ui/react-select"; // who tf are you ?!
```


Pourquoi est-ce un problÃ¨me ? D'abord parce qu'en **s'en remettant Ã  l'API d'un composant externe**, **on perd le bÃ©nÃ©fice d'une implÃ©mentation native et performante** du composant `<select>` optimisÃ©e pour le navigateur. Il faut Ã©galement **blinder ces balises alternatives avec toute une sÃ©rie d'attributs pour satisfaire les standards d'accessibilitÃ©**. Ensuite parce que cela **nous contraint Ã  ajouter une dÃ©pendance Ã  notre projet** pour Ã©muler un comportement dÃ©jÃ  existant Ã  la seule fin de contourner des limitations stylistiques...

<Image src={ScoobyDooSelect} alt="Le select est enfin dÃ©voilÃ© : il s'agit d'un bouton" className="mx-auto my-8 h-125" width={400} height={300} />

Quitte Ã  utiliser des `<button>` et des `<div>` pour contrefaire notre `<select>`, **pourquoi ne pas tenter une implÃ©mentation personnelle afin de ne pas se reposer sur une librairie externe pour un composant aussi essentiel ?**

Parce que rien n'est moins simple ! Bien des difficultÃ©s vous attendent en raison des **nombreux aspects fonctionnels que doit couvrir un menu dÃ©roulant** prÃ©tendant au titre de `<select>` :

* Navigation au clavier et gestion du focus, notamment pour l'accessibilitÃ© ;
* Adaptation mobile ;
* DÃ©tection du clic Ã  l'extÃ©rieur pour la fermeture ;
* Repositionnement automatique selon la bordure de fenÃªtre la plus proche ;
* Chevauchement possible avec d'autres Ã©lÃ©ments notamment lors du scroll

<span className="w-full text-center text-[26px]!">
ğŸ˜®â€ğŸ’¨
</span>

### Chrome notre sauveur (again)

Mais voilÃ  que depuis peu avec Chrome et les navigateurs basÃ©s sur Chromium comme Edge, on peut enfin **styliser un** `<select>` **jusque dans ses moindres dÃ©tails** tout en profitant de ses fonctionnalitÃ©s natives !

<div className="border border-px border-gray-300 rounded-md p-4">
  <BaselineStatus featureId="customizable-select" />
</div>
<br/>

La premiÃ¨re Ã©tape consiste Ã  **dÃ©sactiver le style par dÃ©faut du** `<select>` **choisi par votre navigateur** en optant pour la nouvelle propriÃ©tÃ© `appearance: base-select`.

```scss
select {
  appearance: base-select;
}

// Vous pouvez Ã©galement demander le style minimaliste pour la liste d'options
select::picker(select) {
  appearance: base-select;
}
```

On obtient alors un `<select>` minimaliste et dÃ©sormais totalement personnalisable !

<BaseSelect />

Certes rien de fou Ã  premiÃ¨re vue, celui-ci paraÃ®t mÃªme moins esthÃ©tique ainsi dÃ©pouillÃ© de ses plus beaux atours. Mais croyez-moi, ce `<select>` offre de toutes nouvelles possibilitÃ©s.

<center>
Explorons-en quelques-unes ! ğŸ’
</center>

#### InsÃ©rer des images ou des svg

DorÃ©navant, il est possible **d'insÃ©rer des Ã©lÃ©ments visuels (images, svg etc.)** qui Ã©taient auparavant ignorÃ©s par le *parser* du navigateur. Exemple avec ce sÃ©lecteur de frameworks Javascript ğŸ‘‡

<BaseSelectFrameworks />

```html
<select>
  <selectedcontent></selectedcontent>
  <option>
    <svg aria-hidden>â€¦</svg> // ğŸ–¼ï¸ Logo
    <span>React</span>
  </option>
  <option>
    <svg aria-hidden>â€¦</svg> // ğŸ–¼ï¸ Logo
    <span>Vue</span>
  </option>
  <option>
    <svg aria-hidden>â€¦</svg> // ğŸ–¼ï¸ Logo
    <span>Angular</span>
  </option>
</select>
```
<br/>

Plus globalement le `<select>` customisable accepte n'importe quel HTML dans ses `<option>` alors que le `<select>` classique rÃ©cupÃ©rait uniquement le nÅ“ud textuel.

#### Customiser l'Ã©lÃ©ment sÃ©lectionnÃ©

Souvent l'Ã©lÃ©ment sÃ©lectionnÃ© a des contraintes d'affichage qui diffÃ¨rent de celles des options de la liste de choix possibles. La balise `<selectedcontent>` permet ainsi de cibler spÃ©cifiquement l'Ã©lÃ©ment actuellement sÃ©lectionnÃ© et de lui appliquer ensuite des styles personnalisÃ©s.

```html
<select>
    <selectedcontent></selectedcontent> // ğŸ‘ˆ L'Ã©lÃ©ment sÃ©lectionnÃ©
  <option>
    <svg aria-hidden>â€¦</svg>
    <span>React</span>
  </option>
  <option>
    <svg aria-hidden>â€¦</svg>
    <span>Vue</span>
  </option>
  <option>
    <svg aria-hidden>â€¦</svg>
    <span>Angular</span>
  </option>
</select>
```

```css
selectedcontent {
    display: flex;
    align-items: center;
    gap: 8px;

    svg {
        width: 24px;
        height: 24px;
    }

    span {
        font-weight: bold;
    }
}
```

Ce `<selectedcontent>` agit comme un *slot* Ã  l'intÃ©rieur duquel se tÃ©lÃ©porte l'`<option>` actuellement sÃ©lectionnÃ©e.

Essayons ainsi de reproduire **le bouton Github pour choisir le type de merge** Ã  l'issue d'une PR oÃ¹ l'option sÃ©lectionnÃ©e doit prÃ©senter un aspect diffÃ©rent de l'option affichÃ©e dans la listeğŸ‘‡

<BaseSelectGithub/>


### DiffÃ©rences notables

Lorsque vous passer en `appearance: base-select;` quelques diffÃ©rences subtiles sont Ã  prendre en compte :

- Le `<select>` ne prend plus automatiquement la largeur de l'`<option>` la plus longue.
- Le `<select>` ne dÃ©clenche plus automatiquement les composants mobiles spÃ©cifiques.

<div className="useful-links">
    #### ğŸ”— Liens additionnels
    - <LinkWithGlimpse url="https://developer.chrome.com/blog/a-customizable-select">Chrome for Developers - The &lt;select&gt; element can now be customized with CSS</LinkWithGlimpse>
    - <LinkWithGlimpse url="https://una.im/select-updates/">Updates to the customizable select API</LinkWithGlimpse>
    - <LinkWithGlimpse url="https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Forms/Customizable_select">MDN - Customizable select elements</LinkWithGlimpse>
    - <LinkWithGlimpse url="https://chrome.dev/css-wrapped-2025/#customizable-select">CSS Wrapped 2025</LinkWithGlimpse>
</div>
