import ClassicSelect from "./assets/classic-select";
import ClassicSelectBase from "./assets/classic-select-base";
import ClassicSelectBaseFrameworks from "./assets/classic-select-base-frameworks";
import LinkWithGlimpse from "@/markdown/-components/link-with-glimpse";
import { Select, SelectContent, SelectGroup, SelectItem, SelectLabel, SelectTrigger, SelectValue } from "./assets/shadcn-select";

export const metadata = {
    title: "Les dropdowns personnalisÃ©s sont enfin lÃ  ğŸ‘¨â€ğŸ¨ ",
    date: "2025-12-24",
    excerpt: "Eh ouais, plus besoin de passer par une librairie pour avoir des selecteurs stylÃ©s ğŸ˜",
}

Tout dÃ©veloppeur frontend **connaÃ®t comme sa poche le bon vieil** `<select>` **utilisÃ© pour crÃ©er un menu dÃ©roulant**, l'un des tout premiers avec lesquels on joue lorsqu'on fait ses gammes en HTML.

<ClassicSelect />

```html
<select>
    <option value="1">Apple ğŸ</option>
    <option value="2">Banana ğŸŒ</option>
    <option value="3">Cherry ğŸ’</option>
</select>
```

Bien que simple Ã  utiliser, **cet Ã©lÃ©ment** `<select>` **Ã©tait jusqu'Ã  prÃ©sent trÃ¨s peu personnalisable** au grand dam des dÃ©veloppeurs chargÃ©s d'intÃ©grer des maquettes avec des spÃ©cifications prÃ©cises.

**Impossible, par exemple, de changer directement la flÃ¨che Ã  droite du selecteur** ou **l'apparence des options du menu dÃ©roulant** sans des stratÃ©gies de contournement en CSS assez lourdes.

On se retrouvait donc **coincÃ© avec un rendu visuel dictÃ© par la *user-agent style* du navigateur ou du systÃ¨me d'exploitation de l'utilisateur** ce qui signifie que l'apparence varie d'une plateforme Ã  l'autre. Inexploitable pour un site ou une application avec une identitÃ© visuelle cohÃ©rente...

La tentation Ã©tait alors forte de **recrÃ©er soi-mÃªme** un `<select>` en bricolant avec des `<div>` ou des `<button>` ou de **se tourner vers des librairies de composants** pour avoir complÃ¨tement la main sur son apparence.

Dans cette catÃ©gorie, le `select` de la librairie <LinkWithGlimpse url="https://ui.shadcn.com/docs/components/select">Shadcn UI</LinkWithGlimpse> est l'un des plus utilisÃ©s ğŸ‘‡

<div className="max-w-[200px] flex my-10 flex-col gap-2 mx-auto">
 <label className="font-bold text-decoration-underline" htmlFor="select">
   <span> `<select>` Shadcn UI </span>
 </label>
 <Select>
      <SelectTrigger className="w-[180px]">
        <SelectValue placeholder="Select a fruit" />
      </SelectTrigger>
      <SelectContent>
        <SelectGroup>
          <SelectItem value="apple">Apple ğŸ</SelectItem>
          <SelectItem value="banana">Banana ğŸŒ</SelectItem>
          <SelectItem value="cherry">Cherry ğŸ’</SelectItem>
          <SelectItem value="blueberry">Blueberry ğŸ«</SelectItem>
          <SelectItem value="grapes">Grapes ğŸ‡</SelectItem>
          <SelectItem value="kiwi">Kiwi ğŸ¥</SelectItem>
          <SelectItem value="lemon">Lemon ğŸ‹</SelectItem>
        </SelectGroup>
      </SelectContent>
    </Select>
</div>

Mais Ã  la lecture du code source, on rÃ©alise toutefois qu'**il ne s'agit pas d'un vrai `<select>`** mais d'un `<button>` augmentÃ© de plusieurs attributs et qui requiert d'importer une petite librairie Javascript `@radix-ui/react-select` pour reproduire fidÃ¨lement le comportement d'un `<select>` natif.

Pourquoi n'est-ce pas complÃ¨ment satisfaisant ? D'abord parce qu'en **s'en remettant Ã  l'API (plus ou moins ouverte) d'un composant externe**, **on perd le bÃ©nÃ©fice d'une implÃ©mentation native et performante** du composant `<select>` optimisÃ©e pour le navigateur. Ensuite parce que cela requiert d'ajouter une dÃ©pendance Ã  notre projet pour Ã©muler ce comportement dÃ©jÃ  existant.

**Pourquoi ne pas tenter alors une implÃ©mentation personnelle de notre `<select>` ?** LÃ  surgissent les difficultÃ©s en raison des **nombreux aspects fonctionnels Ã  gÃ©rer si on souhaite un menu dÃ©roulant correct** :

* Navigation clavier et gestion du focus (accessibilitÃ©)
* Ouverture d'un composant sÃ©lecteur adaptÃ© pour mobile
* DÃ©tection du clic Ã  l'extÃ©rieur pour la fermeture
* Repositionnement selon la bordure de fenÃªtre la plus proche
* Chevauchement possible avec d'autres Ã©lÃ©ments, adaptation mobile et tablette etc.

<div className="w-full text-center text-[26px]!">
ğŸ˜®â€ğŸ’¨
</div>

### Chrome notre sauveur (again)

Mais depuis peu, on peut enfin styliser un `<select>` jusque dans ses moindres dÃ©tails !

La premiÃ¨re Ã©tape consiste Ã  dÃ©sactiver le style par dÃ©faut du `<select>` avec la nouvelle propriÃ©tÃ© `appearance: base-select`.

<ClassicSelectBase />

```scss
.custom-select {
  &, &::picker(select) {
    appearance: base-select;
  }
}
```

Bon rien de bien diffÃ©rent Ã  premiÃ¨re vue, celui-ci paraÃ®t mÃªme moins "beau", mais en rÃ©alitÃ© ce `<select>` offre de toutes nouvelles possibilitÃ©s ğŸ¦¸

Tout d'abord on peut introduire dans chaque option du `<select>` des Ã©lÃ©ments visuels (images, svg etc.) qui dans l'implÃ©mentation classique Ã©taient ignorÃ©s par le *parser* du navigateur âœ‚ï¸

<ClassicSelectBaseFrameworks />

```html
<select class="custom-select">
  <option>
    <svg aria-hidden>â€¦</svg>
    <span>React</span>
  </option>
  <option>
    <svg aria-hidden>â€¦</svg>
    <span>Vue</span>
  </option>
  <option>
    <svg aria-hidden>â€¦</svg>
    <span>Angular</span>
  </option>
</select>
```

<div className="useful-links">
    #### ğŸ”— Liens additionnels
    - <LinkWithGlimpse url="https://developer.chrome.com/blog/a-customizable-select">Chrome for Developers - The &lt;select&gt; element can now be customized with CSS</LinkWithGlimpse>
    - <LinkWithGlimpse url="https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Forms/Customizable_select">MDN - Customizable select elements</LinkWithGlimpse>
    - <LinkWithGlimpse url="https://chrome.dev/css-wrapped-2025/#customizable-select">CSS Wrapped 2025</LinkWithGlimpse>
</div>
