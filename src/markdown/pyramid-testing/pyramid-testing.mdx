import ExternalLink from "@/markdown/-components/external-link";
import InformationBanner from "@/markdown/-components/information-banner";
import Pyramid from "./assets/pyramid.png";
import Comparison from "./assets/comparison-pyramid-trophy.png";
import Image from "next/image";

export const metadata = {
  title: "Comment bien tester une application frontend en 2025 ? ğŸ§ª",
  date: "2025-09-27",
  excerpt: "Tu ne fais que des TU Ã  la chaÃ®ne ? ArrÃªte.",
  publish: true,
};

### L'automatisation des tests

Une application robuste est avant tout une **application bien testÃ©e** : pas de crash inattendu ou de rÃ©gression entre chaque dÃ©ploiement. 

L'erreur Ã©tant humaine, l'industrie a su progressivement dÃ©velopper des outils pour **automatiser ces tests** et se passer des vÃ©rifications manuelles, fastidieuses et peu fiables. Les tests automatisÃ©s sont dorÃ©navant **un maillon essentiel dans n'importe quelle CI/CD digne de ce nom** et **leur succÃ¨s un prÃ©alable requis Ã  toute passage en production**. 

### L'approche pyramidale

Mais la mise en place de tests dans une application complexe **emporte aussi avec elle son lot de piÃ¨ges et d'arbitrages techniques**. Car on ne sait jamais trop par oÃ¹ commencer, ni ce qu'on doit tester exactement... La fameuse [Â« pyramide de tests Â» popularisÃ©e par Mike Cohn et reprise par Martin Fowler](https://martinfowler.com/articles/practical-test-pyramid.html) sert souvent de feuille de route :

<Image src={Pyramid} alt="Pyramide de tests" className="w-[80%] mx-auto my-12" />

Elle se dÃ©compose ainsi :

ğŸ‘‰ **BEAUCOUP de tests unitaires** simples et rapides (fonctions mÃ©tiers, utilitaires, fonctions pures etc.)

ğŸ‘‰ **QUELQUES tests d'intÃ©gration** Ã  plus haut niveau (composants avec leurs dÃ©pendances)

ğŸ‘‰ **SI POSSIBLE des tests end-to-end** lents mais plus rÃ©alistes car simulant un navigateur rÃ©el



Dans les faits, on rencontre surtout des **applications bardÃ©es de tests unitaires** (pour celles qui ont des tests...). Ces tests sont gÃ©nÃ©ralement **Ã©crits aprÃ¨s coup, sans stratÃ©gie globale**, avec parfois quelques tests de composant qui surnagent au milieu â€” si on a de la chance ! ğŸ« 

### L'approche trophÃ©e

De plus, **les outils et les frameworks ont Ã©voluÃ© tendant Ã  rendre cette approche pyramidale caduque**. Kent C. Dodds par exemple a dÃ©fendu une version rÃ©visÃ©e de la pyramide avec le Â«Â trophÃ©e de testÂ Â» :

<Image src={Comparison} alt="Pyramide de tests" className="w-[80%] mx-auto my-8" />

#### 1ï¸âƒ£ L'analyse statique

Au pied du trophÃ©e, on trouve d'abord **une couche statique**, forme de Â« test prÃ©ventif Â», assurÃ©e par tous les outils de lint et de typage Ã  notre disposition ([ESLint](https://eslint.org), [Biome](https://biomejs.dev), [Typescript](https://www.typescriptlang.org), [SonarQube](https://www.sonarsource.com/sem/products/sonarqube)). Ces technologies permettent de **dÃ©tecter prÃ©cocement des erreurs syntaxiques**, des **problÃ¨mes de type**, des **anti-patterns** ou d'appliquer des **conventions d'Ã©criture** pour assurer la qualitÃ© et la lisibilitÃ© maximales de votre code. Il ne s'agit pas de tests Ã  proprement parler mais **des sentinelles qui parcourent votre code pour lever rÃ©guliÃ¨rement des alertes**.

#### 2ï¸âƒ£ Les tests unitaires

Vient ensuite une **base de tests unitaires** pour **tester notre logique en isolation**. [Jest](https://jestjs.io) ou [Vitest](https://vitest.dev) (compatible avec Jest mais plus rapide) font Ã§a trÃ¨s bien. 

<InformationBanner status="warning">
Si c'est un reflexe sain que de chercher Ã  tester son code, encore faut-il **se garder du travers de tout tester**, y compris les fonctions les plus triviales. **Sur-tester est certes moins dangereux que sous-tester**, mais tout aussi nocif pour la maintenabilitÃ© du code et expose Ã  bien d'autres problÃ¨mes. Des tests trop Â« pointilleux Â» qui s'attardent sur des dÃ©tails internes aux classes ou fonctions **cassent trÃ¨s facilement Ã  la moindre refactorisation** et finissent immanquablement par **ralentir le dÃ©veloppeur**. Or des tests en surnombre et trop sensibles Ã  un certain type d'implÃ©mentation **favorisent l'inertie dans un projet car ils Ã©lÃ¨vent le coÃ»t de la rÃ©Ã©criture** (il m'a Ã©tÃ© donnÃ© de voir des tests de composant portant sur la prÃ©sence de... classes CSS, tests qu'il fallait donc reprendre dÃ¨s qu'on remaniait un tant soit peu le template ou le jsx du composant ğŸ˜± ). **Inutile donc de fÃ©tichiser un certain pourcentage idÃ©al de couverture de test comme le trÃ¨s ambitieux 100%** : il faut apprendre Ã  tester ce qui gagne Ã  l'Ãªtre et laisser en dehors ce qui ne le vaut pas quitte Ã  Ãªtre un peu en dessous. En somme, il faut **privilÃ©gier la qualitÃ© des tests plutÃ´t que leur quantitÃ©.** 
</InformationBanner>

### 3ï¸âƒ£ Les tests d'intÃ©gration

L'approche Â« trophÃ©e Â» met surtout en vedette **les tests d'intÃ©gration de nos composants**, ces briques essentielles des applications front modernes. [Testing Library](https://testing-library.com) (anciennement React Testing Library) permet dorÃ©navant de gÃ©rer cette partie Ã  moindres frais. On peut mÃªme en coupler l'usage avec [Storybook](https://storybook.js.org) qui permet de gÃ©nÃ©rer une documentation interactive de nos composants, un outil particuliÃ¨rement adaptÃ© si on construit un design system afin d'avoir **tous nos composants sous les yeux dans tous les Ã©tats et actions possibles**.

<InformationBanner>
  La **frontiÃ¨re entre test unitaire et test d'intÃ©gration est historiquement assez floue**. Martin Fowler, [dans la rÃ©ponse qu'il a apportÃ©e Ã  la forme Â« trophÃ©e Â» dÃ©fendue par Kent C. Dodds](https://martinfowler.com/articles/2021-test-shapes.html), rappelle cette difficultÃ© Ã  diffÃ©rencier les deux notions et propose plutÃ´t de distinguer les **tests unitaires Â« solitaires Â»** et les **tests unitaires Â« sociaux Â»**. Dans le cas oÃ¹ on souhaite tester un composant ou une classe isolÃ©ment, on peut choisir soit de conserver les dÃ©pendances qu'il appelle (auquel cas le test est Â« social Â») soit de les remplacer par des _mocks_ ou des _stubs_ (auquel cas le test est Â« solitaire Â»). **Tous deux peuvent prÃ©tendre Ã  l'appellation de test unitaire puisque il s'agit de tester une unitÃ© de code**, ici une classe ou un composant, mais dans le premier on intÃ¨gre Ã  celui-ci ses dÃ©pendances rÃ©elles alors que dans le second on les simule. Pour Fowler, **un test d'intÃ©gration de composant peut Ãªtre vu comme un test unitaire Â« social Â»**. Il ne s'agit donc pas vraiment d'un autre type de test mais **d'une approche diffÃ©rente et complÃ©mentaire du test unitaire** en rÃ©action Ã  l'utilisation excessive de _mocks_.
</InformationBanner>

#### 4ï¸âƒ£ Les tests End-to-End (E2E)

Ces derniers, qui forment le sommet de plus en plus resserrÃ© du trophÃ©e, restent coÃ»teux en temps de calcul et de maintenance mais offrent **l'avantage de rÃ©pliquer des comportements utilisateurs rÃ©els** en faisant tourner sous le capot un navigateur pour interagir avec notre application. Ils demeurent **le seul vrai moyen de tester l'expÃ©rience utilisateur complÃ¨te, y compris les interactions avec des services externes**. [Playwright](https://playwright.dev) et [Cypress](https://www.cypress.io) sont les librairies de rÃ©fÃ©rence dans ce domaine.

<br/>

Bref, que votre structure de tests ressemble Ã  une pyramide, un trophÃ©e ou un Barbapapa, peu importe tant qu'on s'accorde sur un point : les tests (intelligents) ne sont jamais vos ennemis ğŸ¤— Non seulement **ils protÃ¨gent votre application (et votre santÃ© mentale)** en lui Ã©vitant de partir en production avec des mauvaises surprises pour vos utilisateurs, mais ils documentent aussi votre code avec des cas d'usage et vous forcent Ã  anticiper les cas limites qui peuvent survenir. Une attitude de dÃ©veloppement guidÃ©e par l'Ã©criture des tests a Ã©galement plus de chances **de vous alerter rapidement si vous faites fausse route dans votre implÃ©mentation**. La blague court souvent parmi les dÃ©veloppeurs, pour moquer la paresse que nous inspirent les tests, que tester, c'est douter. **En rÃ©alitÃ©, bien tester, c'est ne plus douter !**

<div className="useful-links">
    #### ğŸ”— Liens additionnels

    - <ExternalLink /> [Francisco Moretti - What tests to write for React](https://www.franciscomoretti.com/blog/what-tests-to-write-for-react)
    - <ExternalLink /> [Martin Fowler - Test Pyramid](https://martinfowler.com/bliki/TestPyramid.html)
    - <ExternalLink /> [Ham Vocker - The Practical Test Pyramid](https://martinfowler.com/articles/practical-test-pyramid.html)
    - <ExternalLink /> [Martin Fowler - On the Diverse And Fantastical Shapes of Testing](https://martinfowler.com/articles/2021-test-shapes.html)
</div>