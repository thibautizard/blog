import ExternalLink from "@/markdown/-components/external-link";
import InformationBanner from "@/markdown/-components/information-banner";
import Pyramid from "./assets/pyramid.png";
import Comparison from "./assets/comparison-pyramid-trophy.png";
import Image from "next/image";

export const metadata = {
  title: "Comment tester une application frontend en 2025 ? üß™",
  date: "2025-09-27",
  excerpt: "Tu ne fais que des TU √† la cha√Æne ? Arr√™te.",
  publish: true,
};

### L'automatisation des tests

Une application fiable et robuste est avant tout une **application bien test√©e** : pas de crash inattendu ou de r√©gression √† chaque d√©ploiement. 

L'erreur √©tant humaine, l'industrie a su progressivement d√©velopper des outils pour **automatiser ces tests** et se passer des v√©rifications manuelles, fastidieuses et peu fiables. Les tests automatis√©s sont dor√©navant **un maillon essentiel dans n'importe quelle CI/CD digne de ce nom** et **leur succ√®s un pr√©alable requis √† tout d√©ploiement en production**. 

### L'approche pyramidale

Mais ils emportent aussi avec eux leur lot de pi√®ges et d'arbitrages techniques complexes. Ainsi on ne sait jamais trop par o√π commencer, ni ce qu'on doit faire exactement... On prend alors comme point de d√©part la fameuse [¬´ pyramide de tests ¬ª popularis√©e par Mike Cohn et reprise par Martin Fowler](https://martinfowler.com/articles/practical-test-pyramid.html) :

<Image src={Pyramid} alt="Pyramide de tests" className="w-[80%] mx-auto my-12" />

üëâ **BEAUCOUP de tests unitaires** simples et rapides (fonctions m√©tiers, utilitaires, fonctions pures etc.)

üëâ **QUELQUES tests d'int√©gration** √† plus haut niveau (composants avec leurs d√©pendances)

üëâ **SI POSSIBLE des tests end-to-end** lent mais plus r√©alistes car simulant un navigateur r√©el



Dans les faits, on rencontre surtout des **applications bard√©es de tests unitaires** (pour celles qui en ont...). Ces tests sont g√©n√©ralement √©crits apr√®s coup, sans strat√©gie globale, avec quelques tests de composant qui surnagent au milieu si on a de la chance ü´†

### L'approche troph√©e

De plus, les outils et les frameworks ont √©volu√© tendant √† rendre cette approche pyramidale caduque. Kent C. Dodds notamment favorise une version r√©vis√©e de la pyramide avec le ¬´¬†troph√©e de test¬†¬ª :

<Image src={Comparison} alt="Pyramide de tests" className="w-[80%] mx-auto my-8" />

#### 1Ô∏è‚É£ L'analyse statique

Au pied du troph√©e, on trouve **une couche statique**, forme de "test pr√©ventif" assur√©e par tous les outils de lint et de typage √† notre disposition ([ESLint](https://eslint.org), [Biome ‚ù§Ô∏è](https://biomejs.dev), [Typescript](https://www.typescriptlang.org), [SonarQube](https://www.sonarsource.com/sem/products/sonarqube)). Ceux-l√† permettent de **d√©tecter pr√©cocement des erreurs syntaxiques**, des **probl√®mes de type**, des **anti-patterns** ou d'appliquer des **conventions d'√©criture** pour assurer la qualit√© et la lisibilit√© maximales de votre code.

#### 2Ô∏è‚É£ Les tests unitaires

Vient ensuite une **bonne base de tests unitaires** pour v√©rifier notre logique en isolation. [Jest](https://jestjs.io) ou [Vitest](https://vitest.dev) (compatible avec Jest mais plus rapide) font √ßa tr√®s bien. 

<InformationBanner status="warning">
On doit toutefois **se garder du travers de tout tester**, jusqu'aux fonctions les plus triviales. Si **sur-tester est peut-√™tre moins dangereux que sous-tester**, cela est tout aussi nocif pour la maintenabilit√© du code et expose √† bien d'autres probl√®mes. Des tests trop "pointilleux" qui s'attardent sur des d√©tails d'impl√©mentation interne aux classes ou fonctions et **cassent √† la moindre refactorisation** finissent immanquablement par ralentir inutilement le d√©veloppeur et favorisent l'inertie dans un projet (j'ai d√©j√† vu des tests portant sur la pr√©sence de... classes CSS üò±). **Inutile donc de f√©tichiser un certain pourcentage id√©al de couverture de test comme le tr√®s ambitieux 100%** : il faut tester tactiquement ce qui gagne √† l'√™tre.
</InformationBanner>

### 3Ô∏è‚É£ Les tests d'int√©gration

L'approche troph√©e met surtout en vedette **les tests d'int√©gration de nos composants**, qui sont devenues les briques essentielles des applications front modernes. [Testing Library](https://testing-library.com) (anciennement React Testing Library) permet de g√©rer cette partie et √† moindres frais dor√©navant. On peut en coupler l'usage avec [Storybook](https://storybook.js.org), adapt√© si on construit tout un design system afin d'avoir **tous nos composants sous les yeux dans tous les √©tats et actions possibles**.

<InformationBanner>
  La **fronti√®re entre test unitaire et test d'int√©gration est historiquement assez floue**. Martin Fowler, [dans la r√©ponse qu'il a apport√©e √† la forme troph√©e propos√©e par Kent C. Dodds](https://martinfowler.com/articles/2021-test-shapes.html), rappelle cette difficult√© et propose plut√¥t de distinguer les **tests unitaires "solitaires"** et les **tests unitaires "sociaux"**. Dans le cas o√π on souhaite tester un composant ou une classe isol√©ment, on peut choisir soit de conserver les d√©pendances qu'il appelle (auquel cas le test est social) soit de les remplacer par des _mocks_ ou des _stubs_ (auquel cas le test est solitaire). **Tous deux peuvent pr√©tendre √† l'appellation de test unitaire puisque il s'agit de tester une unit√© de code**, ici une classe ou un composant, mais dans le premier on int√®gre √† celui-ci ses d√©pendances r√©elles alors que dans le second on les simule. Pour Fowler, **un test d'int√©gration est simplement un test unitaire "social"** qui rejette l'utilisation excessive de _mocks_.
</InformationBanner>

#### 4Ô∏è‚É£ Les tests End-to-End (E2E)

Ces derniers, qui forment le sommet de plus en plus resserr√© du troph√©e, sont toujours plus co√ªteux en temps de calcul et de maintenance mais offrent **l'avantage de r√©pliquer des comportements utilisateurs r√©els** en faisant tourner sous le capot un navigateur pour interagir avec notre application. Ils sont le seul vrai moyen de tester l'exp√©rience utilisateur compl√®te, y compris les interactions avec des services externes. [Playwright](https://playwright.dev) et [Cypress](https://www.cypress.io) sont les librairies de r√©f√©rence dans ce domaine.

<br/>

Surtout, les tests (intelligents) ne sont jamais vos ennemis ü§ó Non seulement **ils prot√®gent votre application (et votre sant√© mentale)** en lui √©vitant de partir en production avec des vices cach√©s, mais ils documentent votre code avec des cas d'usage. Une attitude de d√©veloppement guid√©e par l'√©criture des tests a √©galement plus de chances **de vous alerter rapidement si vous faites fausse route dans votre impl√©mentation**. Bien tester, c'est ne plus douter !

<div className="useful-links">
    #### üîó Liens additionnels

    - <ExternalLink /> [Francisco Moretti - What tests to write for React](https://www.franciscomoretti.com/blog/what-tests-to-write-for-react)
    - <ExternalLink /> [Martin Fowler - Test Pyramid](https://martinfowler.com/bliki/TestPyramid.html)
    - <ExternalLink /> [Ham Vocker - The Practical Test Pyramid](https://martinfowler.com/articles/practical-test-pyramid.html)
    - <ExternalLink /> [Martin Fowler - On the Diverse And Fantastical Shapes of Testing](https://martinfowler.com/articles/2021-test-shapes.html)
</div>