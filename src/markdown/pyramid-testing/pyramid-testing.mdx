import ExternalLink from "@/markdown/-components/external-link";
import InformationBanner from "@/markdown/-components/information-banner";
import Pyramid from "./assets/pyramid.png";
import Comparison from "./assets/comparison-pyramid-trophy.png";
import Image from "next/image";

export const metadata = {
  title: "Comment tester une application frontend en 2025 ? ğŸ§ª",
  date: "2025-09-27",
  excerpt: "Tu ne fais que des TU Ã  la chaÃ®ne ? ArrÃªte.",
  publish: true,
};

### L'automatisation des tests

Une application fiable et robuste est avant tout une **application bien testÃ©e** : pas de crash inattendu ou de rÃ©gression Ã  chaque dÃ©ploiement. 

L'erreur Ã©tant humaine, l'industrie a su progressivement dÃ©velopper des outils pour **automatiser le plus possible ces tests** et se passer des vÃ©rifications manuelles nÃ©cessairement fastidieuses, chronophages, incomplÃ¨tes et jamais complÃ¨tement fiables. Les tests automatisÃ©s sont dorÃ©navant **un maillon essentiel dans n'importe quelle CI/CD digner de ce nom** et **leur succÃ¨s un prÃ©alable requis Ã  tout dÃ©ploiement en production**. 

### L'approche pyramidale

Mais ils emportent aussi avec eux leur lot de piÃ¨ges et d'arbitrages techniques complexes. Ainsi on ne sait jamais trop par oÃ¹ commencer, ni ce qu'on doit faire exactement... On prend alors comme point de dÃ©part la fameuse [Â« pyramide de tests Â» proposÃ©e par Martin Fowler](https://martinfowler.com/articles/practical-test-pyramid.html) :

<Image src={Pyramid} alt="Pyramide de tests" className="w-[80%] mx-auto my-12" />

ğŸ‘‰ **BEAUCOUP de tests unitaires** simples et rapides (fonctions mÃ©tiers, utilitaires etc.)

ğŸ‘‰ **QUELQUES tests d'intÃ©gration** Ã  plus haut niveau (sur nos composants)

ğŸ‘‰ **SI POSSIBLE des tests end-to-end** lent mais plus rÃ©alistes car simulant un navigateur rÃ©el



Dans les faits, on rencontre surtout des **applications bardÃ©es de tests unitaires** (pour celles qui en ont...), mais gÃ©nÃ©ralement Ã©crits aprÃ¨s coup, sans stratÃ©gie globale, avec quelques tests de composant qui surnagent au milieu si on a de la chance ğŸ« 

### L'approche trophÃ©e

De plus, les outils et les frameworks ont Ã©voluÃ© tendant Ã  rendre cette approche pyramidale caduque. Kent C. Dodds notamment a proposÃ© une **version rÃ©visÃ©e de la pyramide avec le Â«Â trophÃ©e de testÂ Â»** :

<Image src={Comparison} alt="Pyramide de tests" className="w-[80%] mx-auto my-8" />

#### 1ï¸âƒ£ L'analyse statique

Au pied du trophÃ©e, on trouve **une couche statique** ou de "prÃ©-test" assurÃ©e par tous les outils de lint et de typage Ã  notre disposition ([ESLint](https://eslint.org), [Biome â¤ï¸](https://biomejs.dev), [Typescript](https://www.typescriptlang.org), [SonarQube](https://www.sonarsource.com/sem/products/sonarqube)). Ceux-lÃ  permettent de **dÃ©tecter prÃ©cocement des erreurs syntaxiques**, des **problÃ¨mes de type**, des **anti-patterns** ou d'appliquer des **conventions d'Ã©criture** pour assurer la qualitÃ© et la lisibilitÃ© maximales de votre code.

#### 2ï¸âƒ£ Les tests unitaires

Vient ensuite une **bonne base de tests unitaires** pour vÃ©rifier notre logique en isolation. [Jest](https://jestjs.io) ou [Vitest](https://vitest.dev) (qui ont des API quasi identiques) font Ã§a trÃ¨s bien. 

<InformationBanner status="warning">
On doit toutefois **se garder du travers de tout tester**, jusqu'aux fonctions les fonctions les plus triviales. Si **un sur-test est peut-Ãªtre moins dangereux qu'un sous-test**, il est tout aussi nocif pour la maintenabilitÃ© du code et expose Ã  bien d'autres problÃ¨mes : des tests trop "pointilleux" qui s'attardent sur des dÃ©tails d'implÃ©mentation interne aux classes ou fonctions et **cassent Ã  la moindre refactorisation** finissent immanquablement par ralentir inutilement le dÃ©veloppeur et favorisent l'inertie dans un projet (j'ai dÃ©jÃ  vu des tests portant sur la prÃ©sence de... classes CSS ğŸ˜±). **Inutile donc de fÃ©tichiser un certain pourcentage idÃ©al de couverture de test comme le trÃ¨s ambitieux 100%** : il faut tester tactiquement ce qui gagne Ã  l'Ãªtre.
</InformationBanner>

### 3ï¸âƒ£ Les tests d'intÃ©gration

L'approche trophÃ©e met surtout en vedette **les tests d'intÃ©gration de nos composants**, qui sont devenues les briques essentielles des applications front modernes. [Testing Library](https://testing-library.com) (anciennement React Testing Library) permet de gÃ©rer cette partie et Ã  moindres frais dorÃ©navant. On peut en coupler l'usage avec [Storybook](https://storybook.js.org), adaptÃ© si on construit tout un design system afin d'avoir **tous nos composants sous les yeux dans tous les Ã©tats et actions possibles**.

<InformationBanner>
  La **frontiÃ¨re entre test unitaire et test d'intÃ©gration est historiquement assez floue**. Martin Fowler, [dans la rÃ©ponse qu'il a apportÃ©e Ã  la forme trophÃ©e proposÃ©e par Kent C. Dodds](https://martinfowler.com/articles/2021-test-shapes.html), rappelle cette difficultÃ© et propose plutÃ´t de distinguer les **tests unitaires "solitaires"** et les **tests unitaires "sociaux"**. Dans le cas oÃ¹ on souhaite tester un composant ou une classe isolÃ©ment, on peut choisir soit de conserver les dÃ©pendances qu'il appelle (auquel cas le test est social) soit de les remplacer par des _mocks_ ou des _stubs_ (auquel cas le test est solitaire). **Tous deux peuvent prÃ©tendre Ã  l'appellation de test unitaire puisque il s'agit de tester une unitÃ© de code**, ici une classe ou un composant, mais dans le premier on intÃ¨gre Ã  celui-ci ses dÃ©pendances rÃ©elles alors que dans le second on les simule. Pour Fowler, **un test d'intÃ©gration est simplement un test unitaire "social"** qui rejette l'utilisation excessive de _mocks_.
</InformationBanner>

#### 4ï¸âƒ£ Les tests End-to-End (E2E)

Ces derniers, qui forment le sommet de plus en plus resserrÃ© du trophÃ©e, sont toujours plus coÃ»teux en temps de calcul et de maintenance mais offrant **l'avantage de rÃ©pliquer des comportements utilisateurs rÃ©els** en faisant tourner sous le capot un navigateur pour interagir avec notre app. [Playwright](https://playwright.dev) et [Cypress]() sont les librairies de rÃ©fÃ©rence dans ce domaine.

<br/>

Surtout, les tests (intelligents) ne sont jamais vos ennemis ğŸ¤— Non seulement **ils protÃ¨gent votre application (et votre santÃ© mentale)** en lui Ã©vitant de partir en production avec des vices cachÃ©s, mais ils documentent votre code avec des cas d'usage. Une attitude de dÃ©veloppement guidÃ©e par l'Ã©criture des tests a Ã©galement plus de chances **de vous alerter rapidement si vous faites fausse route dans votre implÃ©mentation**. Bien tester, c'est ne plus douter !

<div className="useful-links">
    #### ğŸ”— Liens additionnels

    - <ExternalLink /> [Francisco Moretti - What tests to write for React](https://www.franciscomoretti.com/blog/what-tests-to-write-for-react)
    - <ExternalLink /> [Martin Fowler - On the Diverse And Fantastical Shapes of Testing](https://martinfowler.com/articles/2021-test-shapes.html)
</div>