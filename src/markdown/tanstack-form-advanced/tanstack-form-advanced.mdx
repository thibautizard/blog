import Image from "next/image"
import Link from "next/link"
import InformationBanner from "@/markdown/-components/information-banner";
import ExternalLink from "@/markdown/-components/external-link";

export const metadata = {
  title: "CrÃ©er des formulaires modernes et type-safe avec TanStack Form ğŸ“ [Bonus]",
  date: "2025-08-16",
  excerpt:
    "Passer Ã  la vitesse supÃ©rieure sur les formulaires avec TanStack Form.",
  publish: true,
};

AprÃ¨s la [mise en place d'un formulaire TanStack Form (partie 1)](/post/tanstack-form-1) puis [l'ajout d'une logique de validation et l'affichage d'erreurs (partie 2)](/post/tanstack-form-2), voici quelques **idÃ©es d'amÃ©lioration faciles dont peuvent bÃ©nÃ©ficier la plupart des formulaire et faciles Ã  mettre en Å“uvre avec TanStack Form**.

### Tip #1 - Ajouter un dÃ©lai avant validation (*debounce*)

Lorsqu'on souhaite valider un *input* Ã  la fin d'une saisie, **introduire un lÃ©ger dÃ©lai avant toute tentative** Ã©vite d'enclencher une validation Ã  chaque saisie de caractÃ¨re qui prÃ©sente peu d'intÃ©rÃªt car **ayant toujours un temps de retard sur ce que l'utilisateur est en train de taper**. Cette pause pour s'assurer que l'*input* est "stabilisÃ©" avant de le tester permet d'optimiser notre formulaire surtout si la validation requiert un appel API. 

Si on combine `OnChangeAsyncDebounceMs` avec `onChangeAsync` on peut ainsi trouver un **rythme de validation plus intelligent et proche de l'instant qu'on souhaite capturer** soit le moment oÃ¹ l'utilisateur a fini de taper ce qu'il avait en tÃªte ğŸ‘‡
<br/>

```tsx {18-22}
  function validateUsername(value: string) {
    fetch(`/api/validate-username?username=${value}`)
      .then(response => response.json())
      .then(data => {
        if (data.error) {
          return "Ce nom d'utilisateur est dÃ©jÃ  pris"
        }
        return null
      })
      .catch(error => {
        return "Une erreur est survenue lors de la validation du nom d'utilisateur"
      })
  }

  <form.Field 
        name="username" 
        validators={
          // Ici pour l'exemple on prend une validation asynchrone
          // mais on peut aussi utiliser des opÃ©rations synchrones
          // dans lesquelles on souhaite introduire un debounce
          onChangeAsyncDebounceMs: 500,
          onChangeAsync: ({ value }) => validateUsername(value),
          onChange: ({ value }) => {
            if (value.length < 3) {
              return "Le nom d'utilisateur doit contenir au moins 3 caractÃ¨res"
            }
          }
        }
        children={({ field }) => 
          <input 
            id={field.id} 
            type="text"
            name={field.name} 
            value={field.state.value}
            onChange={(e) => field.handleChange(e.target.value)}
          />
        }
      />
```


### Tip #2 - Ajouter un indicateur de validation en cours

Quelle que soit la durÃ©e de la validation, n'importe quel champ peut afficher son propre indicateur de validation en regardant la condition `field.getMeta().isValidating`.

```tsx {12}
  <form.Field 
        name="username" 
        children={({ field }) => 
          <>
            <input 
              id={field.id} 
              type="text"
              name={field.name} 
              value={field.state.value}
              onChange={(e) => field.handleChange(e.target.value)}
            />
            {field.getMeta().isValidating && <div>Validation en cours...</div>}
          </>
        }
      />
```

### Tip #3 - Valider plusieurs champs en mÃªme temps

Pensons Ã  l'exemple courant d'un formulaire de crÃ©ation de compte comportant un champ pour entrer un mot de passe et un autre pour le confirmer en le rentrant Ã  l'identique. Chacun de ces champs ne peut Ãªtre valide que **si l'autre contient la mÃªme valeur**. En prÃ©cisant Ã  `onChangeListenTo` ou `onBlurListenTo` de notre champ l'autre champ qu'on souhaite lui lier, on s'assure que **les deux champs sont toujours re-validÃ©s en mÃªme temps mÃªme si l'utilisateur n'interagit qu'avec l'un d'eux**.

```tsx {4,24}
  <form.Field 
        name="password" 
        validators={{
          onChangeListenTo: ["confirmPassword"],
          onChange: ({ value, fieldApi }) => {
            if (value !== fieldApi.form.getFieldValue("confirmPassword")) {
              return "Les mot de passe ne correspondent pas"
            }
          }
        }}
        children={({ field }) => 
            <input 
              id={field.id} 
              type="password"
              name={field.name} 
              value={field.state.value}
              onChange={(e) => field.handleChange(e.target.value)}
            />
        }
      />
  <form.Field 
        name="confirmPassword" 
        validators={{
          onChangeListenTo: ["password"],
          onChange: ({ value, fieldApi }) => {
            if (value !== fieldApi.form.getFieldValue("password")) {
              return "Les mot de passe ne correspondent pas"
            }
          }
        }}
        children={({ field }) => 
            <input 
              id={field.id} 
              type="password"
              name={field.name} 
              value={field.state.value}
              onChange={(e) => field.handleChange(e.target.value)}
            />
        }
      />
```

On remarquera au passage que nous pouvons rÃ©cupÃ©rer au niveau du `field` n'importe quelle valeur du `form` grÃ¢ce Ã  `fieldApi.form.getFieldValue()` ğŸ¤“

### Tip #4 - Utiliser une librairie de validation externe

PlutÃ´t que de dÃ©finir notre logique de validation Ã  l'aide de fonctions passÃ©es dans les `validators` du formulaire ou du champ, **TanStack Form laisse la possibilitÃ© d'utiliser des schÃ©mas de validation** de [Zod](https://zod.dev/), [Valibot](https://valibot.dev/), [ArkType](https://arktype.io/) et autres librairies pour dÃ©finir nos rÃ¨gles.

<InformationBanner>
  L'association de TanStack Form avec une librairie de validation requiert parfois d'installer un adaptateur pour faire le pont entre les deux. Dans le cas de Zod, on l'obtient avec `npm install @tanstack/zod-form-adapter`
</InformationBanner>

On passe ensuite notre schÃ©ma de validation Ã  `onChange`, `onBlur`ou `onSubmit` au niveau du champ... ğŸ‘‡

```tsx {5,22-23}
import { zodValidator } from "@tanstack/zod-form-adapter"
import { z } from "zod"
import { useForm } from "@tanstack/react-form"

const PasswordSchema = z.string().min(8, "Le mot de passe doit contenir au moins 8 caractÃ¨res")

  <form.Field 
        name="password" 
        validators={{
          onChange: ({ value, fieldApi }) => {
            if (value !== fieldApi.form.getFieldValue("confirmPassword")) {
              return "Les mot de passe ne correspondent pas"
            }
          }
        }}
        children={({ field })> 
            <input 
              id={field.id} 
              type="password"
              name={field.name} 
              value={field.state.value}
              validatorAdapter={zodValidator}
              onChange={PasswordSchema}
            />
        }
      />
```

...ou du formulaire tout entier ğŸ‘‡

```tsx {5-8,16}
import { useForm } from "@tanstack/react-form"
import { zodValidator } from "@tanstack/zod-form-adapter"
import { z } from "zod"

const LoginSchema = z.object({
  username: z.string().min(3, "Le nom de l'utilisateur doit contenir au moins 3 caractÃ¨res"),
  password: z.string().min(8, "Le mot de passe doit contenir au moins 8 caractÃ¨res")
})

const form = useForm({ 
  defaultValues: {
    username: "",
    password: "",
  },
  validators: {
    onChange: LoginSchema,
  },
  validatorAdapter: zodValidator(),
  onSubmit: async ({ value}) => {
    console.log(value)
  },
 })
```

<div className="useful-links">
  #### ğŸ”— Liens additionnels 
  - <ExternalLink /> [Documentation officielle de TanStack Form](https://tanstack.com/form/latest/docs/overview)
  - <ExternalLink /> [TanStack Form Tutorial - Balastrong](https://www.youtube.com/watch?v=Pf1qn35bgjs&list=PLOQjd5dsGSxInTKUWTxyqSKwZCjDIUs0Y&index=1)
  - <ExternalLink /> [LogRocket â€” TanStack Form vs. React Hook Form](https://blog.logrocket.com/tanstack-form-vs-react-hook-form)
</div>