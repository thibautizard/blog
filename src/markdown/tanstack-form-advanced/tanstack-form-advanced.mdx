import Image from "next/image"
import Link from "next/link"
import InformationBanner from "@/markdown/-components/information-banner";
import ExternalLink from "@/markdown/-components/external-link";

export const metadata = {
  title: "Cr√©er des formulaires modernes et type-safe avec TanStack Form üìù [Bonus]",
  date: "2025-08-16",
  excerpt:
    "Passer √† la vitesse sup√©rieure sur les formulaires avec TanStack Form.",
  publish: true,
};

Apr√®s la [mise en place d'un formulaire TanStack Form (partie 1)](/post/tanstack-form-1) puis [l'ajout d'une logique de validation et l'affichage d'erreurs (partie 2)](/post/tanstack-form-2), voici quelques **id√©es d'am√©lioration faciles dont peuvent b√©n√©ficier la plupart des formulaire et faciles √† mettre en ≈ìuvre avec TanStack Form**.

### Tip #1 - Ajouter un d√©lai avant validation (*debounce*)

Lorsqu'on souhaite valider un *input* √† la fin d'une saisie, **introduire un l√©ger d√©lai avant toute tentative** √©vite d'enclencher une validation √† chaque saisie de caract√®re laquelle pr√©sente peu d'int√©r√™t la plupart du temps car **ayant toujours un train de retard sur ce que l'utilisateur est en train de taper**. Cette pause permet d'optimiser notre formulaire surtout si la validation requiert un appel API en attendant donc que l'*input* soit "stabilis√©" avant de le tester. 

Si on combine `OnChangeAsyncDebounceMs` avec `onChangeAsync` on peut ainsi trouver un **rythme de validation plus intelligent et proche de l'instant qu'on souhaite capturer √† savoir le moment o√π l'utilisateur a fini de taper ce qu'il avait en t√™te** üëá
<br/>

```tsx {18-22}
  function validateUsername(value: string) {
    fetch(`/api/validate-username?username=${value}`)
      .then(response => response.json())
      .then(data => {
        if (data.error) {
          return "Ce nom d'utilisateur est d√©j√† pris"
        }
        return null
      })
      .catch(error => {
        return "Une erreur est survenue lors de la validation du nom d'utilisateur"
      })
  }

  <form.Field 
        name="username" 
        validators={
          // Ici pour l'exemple on prend une validation asynchrone
          // mais on peut aussi utiliser des op√©rations synchrones
          // dans lesquelles on souhaite introduire un debounce
          onChangeAsyncDebounceMs: 500,
          onChangeAsync: ({ value }) => validateUsername(value),
          onChange: ({ value }) => {
            if (value.length < 3) {
              return "Le nom d'utilisateur doit contenir au moins 3 caract√®res"
            }
          }
        }
        children={({ field }) => 
          <input 
            id={field.id} 
            type="text"
            name={field.name} 
            value={field.state.value}
            onChange={(e) => field.handleChange(e.target.value)}
          />
        }
      />
```


### Tip #2 - Ajouter un loader ou un indicateur de validation

```tsx {12}
  <form.Field 
        name="username" 
        children={({ field }) => 
          <>
            <input 
              id={field.id} 
              type="text"
              name={field.name} 
              value={field.state.value}
              onChange={(e) => field.handleChange(e.target.value)}
            />
            {field.getMeta().isValidating && <div>Validation en cours...</div>}
          </>
        }
      />
```

### Tip #3 - Valider plusieurs champs en m√™me temps

Prenons l'exemple courant d'un formulaire de cr√©ation de compte avec un champ pour entrer un mot de passe et un autre invitant l'utilisateur √† le confirmer. Le formulaire ne peut √™tre valide que **si le mot de passe et sa confirmation sont identiques ce qui n√©cessite de contr√¥ler les deux champs simultan√©ment**. En pr√©cisant √† `onChangeListenTo` ou `onBlurListenTo` l'autre champ du formulaire qu'on souhaite lier √† celui qui nous occupe, on s'assure que les deux champs sont toujours re-valid√©s en m√™me temps.

```tsx {4,24}
  <form.Field 
        name="password" 
        validators={{
          onChangeListenTo: ["confirmPassword"],
          onChange: ({ value, fieldApi }) => {
            if (value !== fieldApi.form.getFieldValue("confirmPassword")) {
              return "Les mot de passe ne correspondent pas"
            }
          }
        }}
        children={({ field }) => 
            <input 
              id={field.id} 
              type="password"
              name={field.name} 
              value={field.state.value}
              onChange={(e) => field.handleChange(e.target.value)}
            />
        }
      />
  <form.Field 
        name="confirmPassword" 
        validators={{
          onChangeListenTo: ["password"],
          onChange: ({ value, fieldApi }) => {
            if (value !== fieldApi.form.getFieldValue("password")) {
              return "Les mot de passe ne correspondent pas"
            }
          }
        }}
        children={({ field }) => 
            <input 
              id={field.id} 
              type="password"
              name={field.name} 
              value={field.state.value}
              onChange={(e) => field.handleChange(e.target.value)}
            />
        }
      />
```

### Tip #4 - Utiliser une librairie de validation

Plut√¥t que de d√©finir notre logique de validation dans les `validators` du formulaire ou du champ, TanStack Form laisse la possibilit√© d'utiliser des librairies de validation comme [Zod](https://zod.dev/), [Valibot](https://valibot.dev/) ou [ArkType](https://arktype.io/) pour d√©finir nos sch√©mas de validation.

<InformationBanner>
  La combinaison de ces deux librairies requiert parfois d'installer un adaptateur pour faire le pont entre les deux. Dans le cas de zod on peut utiliser `npm install @tanstack/zod-form-adapter`
</InformationBanner>

Il suffit ensuite de paser notre sch√©ma de validation √† `onChange`, `onBlur`ou `onSubmit` au niveau du champ... üëá

```tsx {21-22}
import { zodValidator } from "@tanstack/zod-form-adapter"
import { z } from "zod"
import { useForm } from "@tanstack/react-form"

const PasswordSchema = z.string().min(8, "Le mot de passe doit contenir au moins 8 caract√®res")

  <form.Field 
        name="password" 
        validators={{
          onChange: ({ value, fieldApi }) => {
            if (value !== fieldApi.form.getFieldValue("confirmPassword")) {
              return "Les mot de passe ne correspondent pas"
            }
          }
        }}
        children={({ field })> 
            <input 
              id={field.id} 
              type="password"
              name={field.name} 
              value={field.state.value}
              validatorAdapter={zodValidator}
              onChange={PasswordSchema}
            />
        }
      />
```

...ou du formulaire tout entier üëá

```tsx {5-8,16}
import { useForm } from "@tanstack/react-form"
import { zodValidator } from "@tanstack/zod-form-adapter"
import { z } from "zod"

const LoginSchema = z.object({
  username: z.string().min(3, "Le nom de l'utilisateur doit contenir au moins 3 caract√®res"),
  password: z.string().min(8, "Le mot de passe doit contenir au moins 8 caract√®res")
})

const form = useForm({ 
  defaultValues: {
    username: "",
    password: "",
  },
  validators: {
    onChange: LoginSchema,
  },
  validatorAdapter: zodValidator(),
  onSubmit: async ({ value}) => {
    console.log(value)
  },
 })
```

<div className="useful-links">
  #### üîó Liens additionnels 
  - <ExternalLink /> [Documentation officielle de TanStack Form](https://tanstack.com/form/latest/docs/overview)
  - <ExternalLink /> [TanStack Form Tutorial - Balastrong](https://www.youtube.com/watch?v=Pf1qn35bgjs&list=PLOQjd5dsGSxInTKUWTxyqSKwZCjDIUs0Y&index=1)
  - <ExternalLink /> [LogRocket ‚Äî TanStack Form vs. React Hook Form](https://blog.logrocket.com/tanstack-form-vs-react-hook-form)
</div>