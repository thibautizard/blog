import SpecialComponent from "./components/special-component";
import BadgeOld from "./components/badge-old";

export const metadata = {
  title: "Utiliser if dans du... CSS üò±",
  date: "2025-07-14",
  excerpt: "Tous aux abris : il est dor√©navant possible de mettre des if dans son propre CSS.",
  publish: true,
};

Le CSS n'en finit plus de se transformer et d'**incorporer toujours plus de nouvelles fonctionnalit√©s** qui requ√©raient auparavant de passer par des pr√©-processeurs type Sass ou Less.

C'est encore le cas avec l'arriv√©e de la tr√®s attendue (et inesp√©r√©e !) fonction `if()` pour styliser un √©l√©ment en fonction de la valeur d'un de ses attributs.

Prenons un cas d'usage assez banal avec ces badges refl√©tant un statut :

<div className="flex flex-wrap max-w-[300px] justify-center gap-3 my-8 mx-auto">
  <BadgeOld status="pending" />
  <BadgeOld status="success" />
  <BadgeOld status="error" />
  <BadgeOld status="warning" />
  <BadgeOld status="info" />
</div>

Chaque badge porte un attribut `data-status`. On souhaite alors diff√©rencier la couleur de chaque badge en fonction de la valeur pass√©e √† `data-status` (`pending`, `success`, `error`, etc.).

### Sans `if()`

Plusieurs solutions sont possibles. Personellement, j'ai l'habitude de **cr√©er des variables CSS** pour contr√¥ler les propri√©t√©s qui m'int√©ressent et d'en modifier ensuite les valeurs dans les diff√©rents sous-s√©lecteurs de type `[data-status="XXX"]`.

```css
.badge {
  --color: #0ea5e9; /* fallback color */
  --background-color: #cffafe; /* fallback background color */

  border: 1px solid var(--color);
  background-color: var(--background-color);
  color: var(--color);

  /* ... */
}
```

<br />

<BadgeOld status="pending" />
```css
.badge[data-status="pending"] { 
    --color: #9333ea;
    --border-color: #f5f3ff;
}
```

<br />

<BadgeOld status="success" />
```css
.badge[data-status="success"] { 
    --color: #16a34a;
    --background-color: #dcfce7;
}
```

<br />

<BadgeOld status="error" />
```css
.badge[data-status="error"] { 
    --color: #ef4444;
    --background-color: #fee2e2;
}
```

L'inconv√©nient de cette approche est que **la forme conditionnelle n'est pas forc√©ment explicite** et n√©cessite plusieurs s√©lecteurs CSS pour cibler tous les √©tats possibles du badge.

### Avec `if()`

Gr√¢ce √† cette nouvelle fonction `if()`, on peut d√©finir tous ces changements dans le m√™me s√©lecteur :

```css {2}
.badge {
  --status: attr(data-status type(<custom-indent>));

  color: if(
     style(--status: pending): #9333ea; 
     style(--status: success): #16a34a;
     style(--status: error): #ef4444; 
     else: #0ea5e9
  );

  background-color: if(
    style(--status: pending): #f5f3ff,
    style(--status: success): #dcfce7,
    style(--status: error): #fee2e2,
    else: #cffafe
  );
}
```

Tout se joue dans la d√©finition d'une propri√©t√© CSS custom `--status` qui r√©cup√®re automatiquement la valeur de l'attribut HTML `[data-status]` laquelle peut ensuite **√™tre compar√©e pour assigner les styles ad√©quats si la condition est v√©rifi√©e**.

La syntaxe est un poil moins verbeuse ü§è et surtout plus claire dans l'intention.

### Compatibilit√© avec les navigateurs

Comme souvent, **c'est Chrome qui a pris les devants en termes de support** en embarquant le `if()` d√®s la version 137 (sortie fin mai 2025). La plupart des autres navigateurs non bas√©s sur Chromium sont encore aux fraises sur le sujet, **la prudence est donc de mise avant d'envoyer √ßa en production**.

### Est-ce une si bonne id√©e ?

Plut√¥t, dans la mesure o√π on peut r√©gler de **fa√ßon bien plus √©l√©gante** et **maintenable** certains probl√®mes de layout et de style. L'exemple propos√© par **[Una Kravets](https://www.youtube.com/@UnaKravets)** pour classer des tickets dans diff√©rentes colonnes est particuli√®rement ing√©nieux et permet bien de sentir l'int√©r√™t de cette nouvelle fonctionnalit√© üëá

<div className="video-container">
  <iframe
    width="560"
    height="315"
    src="https://www.youtube.com/embed/Apn8ucs7AL0"
    title="YouTube video player"
    frameBorder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    allowFullScreen
    style={{ margin: "2rem auto", maxWidth: "100%" }}
  />
</div>

Le revers de la m√©daille cependant avec ces syntaxes plus "programmatiques" qui √©mergent c'est qu'elles tendent √† **√©loigner le CSS de sa nature tr√®s d√©clarative** et √† le rapprocher d'un langage de programmation avec un co√ªt d'entr√©e et de ma√Ætrise de plus en plus √©lev√©.

Or c'est pr√©cis√©ment cet aspect d√©claratif commun √† HTML et CSS qui permet de limiter la casse lorsqu'on envoyait du CSS trop r√©cent dans des navigateurs avec des versions anciennes puisqu'**il suffit √† l'interpr√©teur de zapper les propri√©t√©s ou valeurs inconnues** ‚Äî l√† o√π un compilateur Javascript crashe m√©chamment s'il croise une syntaxe inconnue post√©rieur √† sa version maximum support√©e.

√Ä voir donc si ce surplus de logique dans le CSS ne va pas **aggraver les probl√®mes de r√©trocompatibilit√© et compliquer le d√©buggage** puisque l'interpr√©tation en deviendra plus d√©licate ‚Äî m√™me si des outils comme [PostCSS](https://postcss.org/) permettent g√©n√©ralement de mitiger cette difficult√© en transpilant le CSS moderne pour le rendre compatible avec les anciennes versions de navigateurs.

<div className="useful-links">
  #### Liens additionnels - üîó 
  - [Documentation MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/if)
</div>
