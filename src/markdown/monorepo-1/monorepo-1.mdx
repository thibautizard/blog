import DependencyGraph from "./assets/dependency-graph.svg";
import ExternalLink from "@/markdown/-components/external-link";
import LinkWithGlimpse from "@/markdown/-components/link-with-glimpse";
import Image from "next/image";

export const metadata = {
    title: "Les avantages d'un monorepo üì¶",
    date: "2025-10-05",
    excerpt: "One repo to rule them all.",
};

Le **monorepo a le vent en poupe depuis plusieurs ann√©es**. Certaines grandes bo√Ætes comme Google, Meta ou Microsoft l'ont m√™me adopt√© de longue date pour centraliser leurs diff√©rents projets **en un seul d√©p√¥t Git**. L'apparition d'**outils d√©di√©s √† leur gestion** facilite aujourd'hui grandement leur utilisation et permettent de tirer un maximum profit de cette organisation tout en **contrebalan√ßant certains de leurs d√©fauts**.

### Un monorepo, qu'est-ce que c'est ?

√Ä mesure qu'un projet se d√©veloppe et se complexifie, on se retrouve √† **devoir travailler sur une multitude de composantes coupl√©es entre elles** : un serveur backend, de multiples interfaces web ou mobiles, des scripts de d√©ploiement, des outils de gestion de contenu, des API REST ou GraphQL, des bases de donn√©es, des tests, des librairies, des configurations en pagaille, des pipelines CI/CD, etc.

En d√©veloppant chacune de ces composantes dans un d√©p√¥t Git s√©par√© (ce qu'on pourrait qualifier d'**approche polyrepo**), on finit par devoir installer et configurer plusieurs d√©p√¥ts si on veut embrasser la totalit√© du projet. La situation se corse d'autant plus lorsque **certaines composantes se trouvent partag√©es par d'autres**. Par exemple, une m√™me logique d'authentification g√©r√©e par un backend mais appliqu√©e √† plusieurs sites ou applications front d'un m√™me projet gagne g√©n√©ralement **√† √™tre extraite sous forme de librairie interne s√©par√©e** (selon le fameux principe DRY, <LinkWithGlimpse url="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">_"Don't Repeat Yourself"_</LinkWithGlimpse>) qui pourra d√®s lors √™tre consomm√©e par plusieurs clients. Reste √† pouvoir **rendre cette librairie accessible, ce qui oblige √† la publier sur un registre de packages en ligne** comme <LinkWithGlimpse url="https://www.npmjs.com">_npm_</LinkWithGlimpse> puis √† l'installer individuellement pour chaque client √† l'aide de `npm publish nom-de-la-librairie` et `npm install nom-de-la-librairie`. Par suite, il faudra r√©guli√®rement **veiller √† ce que toutes les composantes consommatrices de cette librairie soient mises √† jour** √† chaque fois que nous en publierons une nouvelle version afin de conserver une certaine consistance entre toutes nos applications.

Bien d'autres **t√¢ches r√©barbatives tendent √©galement √† se r√©p√©ter d'un d√©p√¥t √† l'autre** que l'on peut citer en vrac : l'acc√®s aux variables d'environnement, les innombrables fichiers de configuration pour le linter, le formatter, la CI/CD, les scripts de d√©ploiement ou de maintenance, etc. Bref **la corv√©e de la configuration et de la maintenance s'alourdit rapidement lorsqu'un projet prend de l'envergure et se diversifie** puisqu'il faut **harmoniser les param√®tres communs** entre les diff√©rents d√©p√¥ts tout en conservant parfois des sp√©cificit√©s locales qui doivent venir surcharger d'autres.

Et s'il existait un moyen **de se d√©lester en grande partie de ce travail fastidieux** et de s'assurer que **diff√©rentes composantes interconnect√©es de notre projet restent parfaitement synchronis√©es en temps r√©el sans avoir √† recharger une nouvelle version de telle ou telle librairie** ? Pour que nos pr√©f√©rences et nos configurations **s'appliquent universellement sans devoir √™tre r√©p√©t√©es** entre chaque d√©p√¥t apparent√© ? Cette solution a un nom : le <u>**monorepo**</u>.

### La recette d'un bon monorepo üßë‚Äçüç≥

Tout d√©p√¥t contenant plusieurs composantes (librairies ou applications) peut √™tre consid√©r√© comme un monorepo. La diff√©rence cruciale va plut√¥t se jouer sur **la mani√®re de g√©rer ces composantes et leurs interactions entre eux**. On peut en effet se contenter d'entasser ces composantes dans un seul d√©p√¥t et de profiter de leur voisinage pour importer directement en interne les parties qui int√©ressent chacun d'entre eux. Mais ce serait passer √† c√¥t√© des gains de productivit√© et de gestion simplifi√©e que peut apporter un monorepo correctement orchestr√©.

Prenons un exemple courant : un monorepo dont **plusieurs applications frontend se partagent une m√™me librairie UI interne**. Par cette simple action, un graph de d√©pendances se dessine entre ces diff√©rents projets :

<Image src={DependencyGraph} alt="Graph de d√©pendances" className="w-[80%] mx-auto" />

Imaginons maintenant que vous `commit` ou `push` la derni√®re version de votre d√©p√¥t ce qui enclenchera probablement un pipeline CI/CD avec des t√¢ches de build et de test. Il est √©vident que le build de l'app #1 ou de l'app #2 ne pourra √™tre ex√©cut√© **qu'apr√®s celui de la librairie interne dont chacune d'elle d√©pend**, de sorte que toute modification de la librairie UI devra entra√Æner **un re-build de toutes les applications qui l'utilisent**.

Cependant, une modification de l'app #1 ou de l'app #2 **n'aura aucun impact sur la librairie interne et ne n√©cessitera pas de recompiler celle-ci**. De m√™me, votre `linter` n'a aucun int√©r√™t √† s'ex√©cuter sur l'ensemble du d√©p√¥t si les derni√®res modifications concernent uniquement une seule application. C'est l√† tout l'int√©r√™t d'outils de gestion de monorepo comme <LinkWithGlimpse url="https://nx.dev">_Nx_</LinkWithGlimpse> ou <LinkWithGlimpse url="https://turbo.build">_Turborepo_</LinkWithGlimpse> qui **optimisent l'ex√©cution de ces diff√©rentes t√¢ches √† l'int√©rieur de votre monorepo** en se servant du graph de d√©pendances qui √©merge spontan√©ment des relations nou√©es dans le code entre vos diff√©rentes composantes. **Vous pouvez m√™me configurer manuellement** jusqu'√† atteindre la pr√©cision parfaite pour votre projet.

Si vous laissez donc grossir votre monorepo sans outils capable de mettre en cache et de parall√©liser les t√¢ches r√©currentes, vous risquez de voir celui-ci devenir un amas de code mal organis√© et **de rapidement constater une d√©gradation des performances et une augmentation des temps de _build_**. Cela exige **un travail de configuration suppl√©mentaire** mais qui se r√©v√®lera tr√®s vite payant. En √©cartant ce risque inh√©rent aux monorepo non orchestr√©, vous pouvez √† pr√©sent savourer pleinement ses avantages üòé

### L'alignement des d√©pendances (_Single Version Policy_)

L'un des aspects les plus importants dans un projet bien trop souvent n√©glig√© est **celui de la gestion des d√©pendances externes et de leurs mont√©es de version**. Beaucoup de projets manquent de cette discipline dans les mises √† jour et se retrouvent progressivement **bloqu√©s par des versions obsol√®tes de d√©pendances externes qui ouvrent des failles de s√©curit√© et interdisent de profiter des derni√®res am√©liorations**.

La raison de cette n√©gligence si r√©pandue tient moins √† l'ignorance de la gravit√© des risques qu'encourt une application aux d√©pendances externes insuffisamment actualis√©es et dont certaines fonctionnalit√©s cessent d'√™tre support√©es en raison de la d√©pr√©ciation de celles-ci, qu'√† **la paresse naturelle qui saisit tout et chacun devant le travail de mise √† niveau** qui exige parfois de se replonger dans le code pour rattraper certains _breaking changes_ introduits par des changements de versions majeures. Le monorepo peut largement att√©nuer ce probl√®me de motivation en permettant de **traiter en un seul coup l'ensemble des d√©pendances externes de toutes les composantes d'un projet** ou en **for√ßant l'adoption de versions identiques pour les librairies les plus importantes**. On peut par exemple s'assurer que toutes nos librairies utilitaires utilisent la m√™me version de Typescript ou que nos applications front s'en tiennent √† la m√™me version de React.

### Un _commit_ pour tous vos changements (_Atomic Changes_)

Dans le cas d'un monorepo contenant une API consomm√©e par une seule application frontend, l'approche monorepo vous permet de **modifier chaque extr√©mit√© de cette cha√Æne de communication et de tester simultan√©ment cette combinaison avant de tout sauvegarder en un seul** `commit`. Au contraire, si votre projet est divis√© en plusieurs d√©p√¥ts, notamment pour la partie front et back, il vous faudra **attendre de devoir r√©cup√©rer une modification faite sur un c√¥t√© avant de pouvoir entamer l'autre** ce qui vous impose des allers-retours entre les diff√©rents d√©p√¥ts. L'√©volution recherch√©e ne pourra appara√Ætre qu'au terme d'une s√©rie de `commits` r√©partis sur diff√©rents d√©p√¥ts. Au contraire,un monorepo vous donne la capacit√© de stocker **l'int√©gralit√© des changements li√©s √† une fonctionnalit√© dans un seul `commit`** ce qui favorise la lisibilit√© et la maintenance de votre code, surtout en cas de `git revert` ou pour faciliter la relecture d'une _pull request_.

### Des configurations harmonis√©es

**L'outillage des projets frontend moderne est g√©n√©ralement toujours le m√™me** : un linter comme ESLint ou Biome, un formatter comme Prettier, un type checker comme Typescript, des hooks de pr√©-commit ou pr√©-pull comme Husky, une configuration Postcss ou Tailwind etc. Chacun de ces outils dispose de son propre fichier de configuration pour activer ou d√©sactiver certains r√©glages plac√© √† la racine du d√©p√¥t dans le cas d'un d√©p√¥t simple. Mais si on dispose de plusieurs applications React, par exemple, **ces configurations tendent √† √™tre les m√™mes d'un d√©p√¥t √† un autre**. En fonctionnant avec des d√©p√¥ts s√©par√©s, on risque de **voir progressivement appara√Ætre et se creuser des √©carts alors qu'une m√™me √©quipe travaille sur cette famille d'applications**.

Quand tous ces projets sont rassembl√©s dans un monorepo, il devient **plus ais√© de placer une configuration de base commune √† tous les projets ou √† certains sous-ensembles (toutes les applications de type React par exemple) afin de maintenir une plus forte coh√©rence**. Cela n'interdit pas des adaptations sp√©cifiques : la plupart de ces outils **autorise des fichiers de configuration compl√©mentaires pour chaque composante** qui viennent √©tendre la configuration de base partag√©e en ajoutant ou en surchargeant certains r√©glages.

<div className="useful-links">
    #### üîó Liens additionnels

    - <ExternalLink/><LinkWithGlimpse url="https://stefanhaas.xyz/article/monorepos-101/">Stefan Haas - Introduction to Frontend Monorepos</LinkWithGlimpse>
    - <ExternalLink/><LinkWithGlimpse url="https://monorepo.tools">monorepo.tools</LinkWithGlimpse>
</div>
