import ExternalLink from "@/markdown/-components/external-link";
// import InformationBanner from "@/markdown/-components/information-banner";

export const metadata = {
  title: "Manipuler des tableaux en JavaScript en toute s√©curit√© üßÆ",
  date: "2025-09-16",
  excerpt:
    "Pourquoi il faut √©viter .sort(), .reverse() ou .splice() et quelles sont leurs alternatives modernes",
  publish: true,
};

### Les m√©thodes natives de JavaScript pour manipuler des tableaux

Historiquement, JavaScript offre son lot de m√©thodes natives pour manipuler des tableaux, mais **toutes ne se comportent pas de la m√™me mani√®re**.

Prenons d'un c√¥t√© `sort()`, `reverse()` ou encore `splice()` :

```js
const numbers = [3, 2, 4, 1, 5]

const reversed = numbers.reverse()
// [5, 1, 4, 2, 3]

const sorted = numbers.sort()
// [1, 2, 3, 4, 5]

console.log(numbers)
// [1, 2, 3, 3, 5] ‚ùó Le tableau original a √©t√© modifi√©
```

Et de l'autre les incontournables `map()`, `filter()` et `reduce()` : 

```js
const numbers = [1, 2, 3, 3, 5]

const doubled = numbers.map(number => number * 2)
// [2, 4, 6, 6, 10]

const filtered = numbers.filter(number => number > 3)
// [5]

console.log(numbers)
// [1, 2, 3, 3, 5] üßò‚Äç‚ôÇÔ∏è Rien n'a chang√©
```

On constate ainsi que certaines m√©thodes **modifient le tableau original** (on les appelle **mutables**), tandis que d'autres **retournent une copie modifi√©e sans toucher √† l'original** (elles sont **immuables**).    

### Le risque des m√©thodes mutables

Et c'est grave docteur ? üò±

Oui car dans un code complexe employer des fonctions ou des m√©thodes qui modifient une valeur plut√¥t que d'en retourner une copie peut **devenir une source de bugs difficiles √† tracer**. Par exemple, si l'on veut trier un tableau avant de le filtrer, on peut √™tre tent√© d'√©crire :  

```js
const numbers = [4, 2, 3, 1, 5]
const sorted = numbers.sort()
// [1, 2, 3, 4, 5]
const filtered = sorted.filter(number => number > 3)
// [4, 5]
```
Contrairement aux apparences et √† la diff√©rence de `filtered`, ici `sorted` **n'est PAS un nouveau tableau mais une r√©f√©rence directe au tableau original** `numbers` **modifi√©**. 

Pourquoi est-ce un probl√®me ? Car si une autre partie de votre code sans rapport avec les lignes pr√©c√©dentes r√©utilise le m√™me tableau `numbers`, elle ne travaillera pas sur la liste attendue `[4, 2, 3, 1, 5]`, mais sur sa version tri√©e `[1, 2, 3, 4, 5]`.

Cette incoh√©rence dans le comportement des m√©thodes de tableau en JavaScript a longtemps √©t√© une **source de confusion** qui n'a clairement pas jou√© en faveur de la r√©putation de ce langage. 

### Des alternatives modernes

Heureusement, _JavaScript is healing üåà_ Depuis ES2023 nous pouvons dor√©navant compter sur des m√©thodes immutables qui nous permettent de **cr√©er un nouveau tableau sans modifier l'original** :

- `toSorted()`
- `toReversed()`
- `toSpliced()`

Ces m√©thodes prennent respectivement le relais de `sort()`, `reverse()` et `splice()`. 

```js
// ‚ùå √Ä √©viter : m√©thodes mutables
const sorted = numbers.sort(); // Modifie l'original

// ‚úÖ Bonne pratique : utiliser les nouvelles m√©thodes immutables
const sorted = numbers.toSorted();
const reversed = numbers.toReversed();
```

Il n'y a plus aucune excuse √† ne pas les employer car toutes ces m√©thodes sont dor√©navant **support√©es par la plupart des environnements modernes** (Chrome/Edge 110+, Safari 16+, Firefox 115+, Node.js 20+).

Pour des [raisons de r√©trocompatibilit√©](https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/get-started/ch1.md#backwards--forwards), les anciennes m√©thodes mutables **ne seront certainement jamais supprim√©es** mais la prudence invite d√©sormais √† les √©viter pour leur pr√©f√©rer leur homologues modernes.